
Evaluation Warning: The document was created with Spire.Doc for Python.
 
 
 
 
 
ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА БАКАЛАВРА 
 
ИССЛЕДОВАНИЕ ПЕРЕМЕЩЕНИЯ МОБИЛЬНЫХ БЕСПРОВОДНЫХ СЕТЕЙ ДЛЯ МОДЕЛИ ДВИЖЕНИЯ УЗЛОВ RANDOM WAYPOINT MODEL
 
	Работу выполнил 	В. А. Комаричев 


СОДЕРЖАНИЕ 
 
Введение ................................................................................................................... 3 
1  Основные понятия Ad hoc сетей ......................................................................... 4 
1.1  Основные понятия и определения ................................................................ 4 
1.2  Область применения сетей Ad hoc ............................................................. 10 
1.3  Математическая модель представления сетей ad hoc .............................. 11 
1.4  Базовые понятия теории графов ................................................................. 13 
1.5  Определения моста, точки сочленения и компоненты связности графа 15 
1.6  Модель Random Waypoint ........................................................................... 17 
1.7  Известные проблемы модели Random Waypoint ...................................... 20 
2  Практическая реализация .................................................................................. 21 
2.1  Среда разработки ......................................................................................... 21 
2.2  Представления графов в практической реализации ................................. 23
2.3   Оценка сложности решений поиска мостов, точек сочленения и компонент связности, приведенных в программе .......................................... 25 
2.4  Структура программы ................................................................................. 25 
2.4.1  Основные блоки программы .............................................................. 25 
2.4.2 Описание работы программы ............................................................ 36 
2.4.3  Анализ результатов ............................................................................. 38 
Заключение ............................................................................................................ 50 
Список использованных источников .................................................................. 51 
Приложение А Код программы ........................................................................... 52 

ВВЕДЕНИЕ 
В настоящее время сети передачи данных продолжают активно развиваться, в том числе все большее распространение получает такой их класс, как сети Ad hoс. Это одно-ранговые беспроводные сети передачи данных с переменной топологией и отсутствием четкой инфраструктуры, где каждый узел может выполнять функции маршрутизатора и принимать участие в ретрансляции пакетов данных. Минимальное конфигурирование и быстрое развёртывание позволяет применять самоорганизующиеся сети в чрезвычайных ситуациях - во время военных действий, в структурах МЧС во время техногенных катастроф и природных бедствий, а так же в системах транспорта и различных силовых структурах.  
Так как на сегодняшний день имитационное моделирование является основным средством, которое позволяет оценить эффективность той или иной модели для самоконфигурируемых мобильных сетей (потому как на данный момент до сих пор не существует формальная основа для оценки эффективности решений, потому что эксперименты на мобильных самоорганизующихся сетях крайне затруднены в силу того, что сложно организовать подобные испытания с большим количеством участников, и уж тем более воссоздать равные условия моделирования для всей серии экспериментов, а так же в связи с внушительными временными затратами), именно имитация сети и оценка результатов были основными целями этой работы. 
 	 
1 Основные понятия Ad hoc сетей 
1.1 Основные понятия и определения 
Ad hoc-сеть (беспроводная динамическая сеть или же беспроводная самоорганизующаяся сеть) — децентрализованная беспроводная сеть, не имеющая устойчивой постоянной структуры. Клиентские устройства соединяются «на лету», тем самым образуя собой сеть. Каждый узел в сети пытается переслать определенные данные другим узлам. При этом, какому именно из узлов осуществлять пересылку данных, определяется динамически, на основании связности сети. Этим ad hoc-сети отличаются от управляемых беспроводных сетей и проводных сетей, в которых задачу управления потоками данных выполняют точки доступа или маршрутизаторы соответственно. На рисунке 1 изображен пример сети Ad hoc. 
 

Рисунок 1 - Пример ad hoc сети 
Топология сети c течением времени может непредсказуемо меняться по различным причинам: во-первых, потому что работающие узлы мобильны, во-вторых, потому что некоторые из неподвижных узлов могут выйти из строя и перестать работать. Периодически в такой сети происходят изменения, в ходе которых меняется местонахождение узлов, следовательно, меняется и расстояние между соседними узлами. Именно поэтому Ad hoc сети можно называть также эпизодическими сетями. Зачастую в качестве эпизодической сети выступает именно беспроводная сеть. 
Эпизодическая сеть является одноранговой, это означает, что все узлы в сети наделены одинаковыми функциями. Каждый из таких узлов может общаться с любым другим, и в этом случае не предусматривается отдельная базовая станция или точка доступа. Но если возникает необходимость подключения этой Ad hoc сети к другой сети, например, такой, как Интернет, один из этих узлов эпизодической сети может быть наделен правами базовой станции или некоторого координатора этой сети. Узлы эпизодической сети имеют ограниченную мощность передатчика, из-за этого они имеют также ограниченную «радиовидимость». Еще одним важным свойством узлов подобной эпизодической сети, не считая прием и передачу, является возможность ретранслировать информацию и маршрутизировать. Каждое устройство в такой сети перемещается независимо от других в абсолютно любом направлении. Самоорганизованность в сетях Ad hoc необходима для того, чтобы была возможность связности узлов. Узлы, во время своего функционирования в сети, используют общий беспроводной канал, причем доступ к нему предоставляется случайным образом. Передача данных в сети реализуется узлами посредством ретрансляции. Поэтому узлы являются не только хостами, но также и маршрутизаторами. Наиболее важными особенностями таких сетей являются: 
* наличие децентрализованного управления и одноранговой структуры; 
* наличие непредсказуемо и динамически меняющейся топологии;  
* наличие функции маршрутизации у всех узлов;  
* наличие самоорганизации сети (через ретрансляцию);  
* наличие различных ограничивающих факторов в сети в виде дальности радиовидимости или ёмкости батарей устройств;  - большая потеря данных. 
Существует несколько видов основных эпизодических сетей (рисунок 2): 
* мобильная эпизодическая сеть (MANET — mobile ad hoc network); 
* фиксированная эпизодическая сеть, пример — беспроводная сенсорная сеть (WSN — wireless sensor network); 
 
Рисунок 2 – Сети с переменной топологией: a) стационарная сеть; б) сеть с подвижными узлами; в) сеть с отказавшими узлами 
У сетей MANET также есть свои разновидности, среди которых:  
* VANET — автомобильная ad hoc сеть (vehicular ad hoc network); 
* InVANET — эпизодическая сеть на основе роботизированных 
мобильных систем (intelligent VANET); 
* IMANET — эпизодическая сеть с возможностью выхода на фиксированную сеть Интернет (internet MANET); 
* WANET — беспроводная эпизодическая сеть с подвижными базовыми станциями (wireless ad hoc network);  
* WMN — беспроводная клеточная (ячеистая) сеть (wireless mesh networks);  
* Airborne Ad Hoc Network — эпизодическая сеть, приёмопередатчики которой находятся на воздушных платформах.  
В таблице 1 приведена сравнительная характеристика сетей. 
Таблица 1 – Сравнительная характеристика сетей 
Тип сети 
Мобильность 
Энергетика 
Вычислительная мощность 
MANET 
Низкая 
Ограничена 
Средняя 
VANET 
Высокая 
Не ограничена 
Высокая 
Проводная 
Отсутствует 
Не ограничена 
Высокая 
 
Для того чтобы полностью классифицировать эпизодическую сеть используют разные свойства и признаки, такие как:  
* архитектура сети (одноранговая или с выходом в другие сети); 
* мобильность (мобильные узлы или фиксированные); 
* взаимное размещение узлов в пространстве (плоское, линейное или трехмерное);  
* число узлов (малое, среднее, большое, огромное); 
* скорость (время) изменения топологии (секунды, минуты, часы, дни) и т.д.  
Из-за подвижности абонентов топология сети постоянно и непредсказуемо меняется (рисунок 3). Простейшим видом связи является передача между соседними узлами — напрямую (в один скачок). Для передачи информации между произвольными узлами, как правило, требуется многоскачковая (релейная) трансляция, причем набор промежуточных узлов из-за их мобильности может меняться даже в ходе сеанса связи. Поскольку Ad hoc сеть является одноранговой, то в процессе одновременной передачи информации несколькими узлами могут возникать конфликтные ситуации, и не только в отношении общего канала связи. Например, мобильный аппарат должен работать для одного маршрута, как оконечный приемник, а для другого маршрута — как ретранслятор. 
 
Рисунок 3 – Влияние движения узлов на топологию сети: a) прямая передача; 
б) релейная передача(в две скачка); в) конфликт в узле 
Эпизодическая сеть может работать независимо или подключаться к другим сетям, например, к Интернет, через соответствующие устройства. Концепция эпизодических сетей имеет большие перспективы как с точки зрения возможностей развития следующего поколения сетей, так и с точки зрения концепции всепроникающих телекоммуникаций (omnicommunications). Базовыми характеристиками эпизодических сетей, отражающими их специфику, являются:  
* среднее число функционирующих узлов в сети;  
* подвижность узлов;  
* предельная ёмкость сети;  
* гарантированная емкость сети;  
* максимальное (гарантированное, среднее) время пересылки в сети;  
* связность или среднее число соседних узлов в зоне радиовидимости; 
* живучесть сети или вероятность доставки информации любому действующему узлу в сети;  
* мортальность узлов (пропадание, выход из зоны видимости узлов за определенный срок, среднее значение).  
Вместе с тем нужно упомянуть о преимуществах эпизодических сетей: 
* относительная простота — не требуется предварительная установка стационарного оборудования; 
* гибкость – сеть легко разворачивается в любое время в любом месте; 
* обеспечение доступа к информации и услугам без привязки к географическому расположению абонентов; 
* возможность быстрой реконфигурации в условиях помех или иных неблагоприятных обстановках; 
* высокая скорость развертывания; 
* возможность передавать данные на большие расстояния без увеличения мощности передатчика; 
* устойчивость к изменениям в инфраструктуре сети. 
Перечислим особенности эпизодических сетей с точки зрения применения в специализированных системах, обусловленные хорошо развитым алгоритмическим и программным обеспечением: 
* поддержка интерактивного обмена информацией в реальном времени; 
* высокие требования по энергетической эффективности; 
* устойчивость к наведенным помехам; обильность магистральной линии;  
* устойчивость к прерываниям связи;  
* управление безопасностью и обеспечение живучести;  
* обнаружение несанкционированного доступа;  
* эффективность и безопасность маршрутизации;  
* динамическая адресация;  
* адекватная емкость сети.  
 
1.2 Область применения сетей Ad hoc 
 
Область применения эпизодических сетей широка и разнообразна. Ad hoc сети могут быть применены в самых различных отраслях науки и техники. В таблице 2 приведены области, в которых могут быть применены эпизодические сети. 
Таблица 2 – Области применения мобильных эпизодических сетей 
Область применения 
Описания/службы 
Сенсорные сети 
Домашние приложения: умные сенсорные узлы и устройства управления могут быть встроены в технику, 
чтобы конечные пользователи могли управлять бытовой техникой локально или удаленно. 
Домашние и представительские 
сети 
Домашние/офисные беспроводные сети (WLAN), например, использование общедоступных лекционных 
экранов, использование карманных компьютеров для печати документов из любого места, торговые презентации. Персональные сети 
Коммерческие приложения 
Электронная коммерция: электронные платежи из любого места. Бизнес. Динамический доступ к данным, которые хранятся в центральном хранилище. 
Представление согласованных баз данных агентам. 
Мобильный офис. Сервисы для транспортных средств. 
Передача новостей, состояния дорог, прогноза погоды, музыки. Локальная эпизодическая сеть с транспортными средствами для получения информации о дороге/дорожных происшествиях. 
Развлечения 
Многопользовательские игры, роботизированные питомцы. Доступ в Internet на улице 
Работы при чрезвычайных ситуациях 
 
 
Поисковые и спасательные ситуации. Устранение последствий чрезвычайных ситуаций. Ранее получение и доставка данных о пациенте (запись, статус, 
диагностика) из/в госпиталь. Замена фиксированной инфраструктуры в случае землетрясения, урагана или 
Область применения 
Описания/службы 
 
 иного стихийного бедствия. 
Тактические сети 
Военные коммуникации, операции. Автоматизированные поля сражений. 
Сервисы для определения местоположения 
Сервисы по отслеживанию автоматической переадресации вызова, передачи интеллектуальной информации о текущем местоположении. 
Информационные сервисы: от абонента - информация о местонахождении определенного сервиса в зависимости 
от местоположения, например, заправочной станции, к абоненту - туристический гид в зависимости от 
местоположения, информация о доступных сервисах 
(принтер, факс, телефон, сервер, заправочные станции). 
Учебные приложения 
Установка виртуальных классов или комнат для конференций. Установление эпизодических коммуникаций во время мероприятий. 
 
 
1.3 Математическая модель представления сетей ad hoc 
 
Математическая модель расположения на плоскости ad hoc сети представляет собой объединение кругов заданных радиусов. В области расположения сети имеется естественный электромагнитный шум некоторого уровня. В центре одного из кругов (a) находится передатчик сигналов. Уровень электромагнитного поля, создаваемого передатчиком, уменьшается при удалении от центра круга. Радиусом Ra считается такое значение удаления, при котором отношение сигнал/шум соответствует чувствительности стандартного приемника, находящегося на этом удалении. Иначе говоря, при меньшем, чем Ra, удалении приемник способен принять и распознать сигнал, а при большем или равном расстоянии – нет (либо вообще не принимает сигнал, либо не может его декодировать и считает шумом).  
Вершины a и b могут непосредственно обмениваться информацией, тогда и только тогда, когда расстояние между ними d(a, b) < min(Ra, Rb).   Если d(a, b)  max(Ra, Rb), то связи нет.  Если min(Ra, Rb)  d(a, b) < max(Ra, 
Rb), то связь односторонняя. Таким образом, граф компьютерной сети является ориентированным (орграф). В частном случае, когда все радиусы одинаковы, граф является неориентированным. 
Так как математической моделью сети ad hoc, по сути, является так называемый геометрический граф и данная работа состоит в оценке его характеристик в определенные моменты времени, то имеет смысл привести здесь несколько определений из теории графов, которые помогут понятию сути проведенной работы. Если расположение узлов сети изменяется со временем, то получается динамический граф G(t), в котором дуги (ребра) между вершинами – узлами, то исчезают (при удалении узлов друг от друга), то возникают (при приближении узлов). Соответственно, для произвольной пары вершин a и b маршрут, их соединяющий может существовать или не существовать. Если рассматривать связность графа как динамический процесс со значениями (1 – связен, 0 – не связен), то он может быть изображен как скачкообразно меняющаяся функция времени. Также изменяется скачкообразно количество компонент: в момент t0 граф состоит из c0 компонент, и сохраняет это значение до момента t1, когда вследствие появления новых ребер или исключения старых, количество компонент изменяется на целочисленную величину и становится равной c 1. И так далее. Если изобразить этот процесс графиком с осью абсцисс t, и осью ординат c, то получится кусочно-постоянная функция. Конкретный вид функции зависит от закономерностей (x(t), y(t)) перемещения вершин на плоскости (модели мобильности). Поскольку узлы сети располагаются в точках плоскости, можно ввести параметр расстояния между компонентами – расстояния между ближайшими узлами двух компонент. Он важен для прогнозирования вероятности и времени возможного соединения компонент при перемещении узлов. Для прогнозирования возможного разделения графа на компоненты (потери связности) важны такие параметры, как наличие мостов и точек сочленения, их взаимное расположение. 
 
1.4 Базовые понятия теории графов 
Пусть  – конечное множество и  – подмножество множества его двухэлементных подмножеств. Тогда пара  = ( , ) называется (простым) графом c множеством вершин  и множеством ребер . Более простое определение графа - совокупность точек и линий, в которой каждая линия соединяет две точки. Ребром может быть прямая или кривая линия. Ребра не могут иметь общих точек кроме вершин (узлов) графа. Замкнутая кривая в E может иметь только одну точку из множества V, а каждая незамкнутая кривая в E имеет ровно две точки множества V. На рисунке 4 изображен пример графа. 
 
 
Рисунок 4 – Пример графа 
Если V и E конечные множества, то и граф им соответствующий называется конечным. Параллельными ребрами графа называются такие, которые имеют общие узлы начала и конца. Вершины  и  графа  смежны, если последний содержит ребро ( , ):= { , }; в этом случае говорим также, что вершины  и  инцидентны этому ребру. Две вершины, соединенные ребром, могут совпадать; такое ребро называется петлей. Если степень вершины равна 0, то получается изолированная вершина. Если два ребра инцидентны одной и той же паре вершин, они называются кратными; граф, содержащий кратные ребра, называется мультиграфом. Степенью вершины  называется число, вычисляемое по формуле 1: 
 
	   	( ) = |	( )|,                                                  (1) 
 
где ( ) = { ∈  : ( , ) ∈ } – множество соседей или окрестность этой вершины. Граф  называется регулярным (степени ), если ( ) =  степени для всех  ∈ . Приведем несколько примеров. 
	Полный граф с 	 вершинами содержит все 	( − 1)/2 ребер; он 
регулярен степени  − 1.  
Пустой граф не содержит ни одного ребра; он регулярен степени 0.  
	Цепь длины  ≥ 0 имеет +1 вершину 0, . . . , 	 и  рёбер вида (	 , 
+1), где  = 0, . . . , −1.  
Цикл длины  ≥ 3 имеет  вершин 1, . . . , 	,  рёбер вида ( , 	+1), где  = 1, . . . ,  − 1, и ребро (	, 1); это регулярный граф степени 2.  
	Вершины 0, . . . , 	 ∈  , где 	 ≥ 0, образуют цепь графа  если ( , 
+1) ∈  при  = 0, . . . , −1; в этом случае вершины 0 и  называются концами цепи, а число −1 её длиной. Цепь называется простой, если все её вершины различны. Отношение на множестве " быть концами цепи в " является отношением эквивалентности. Для каждого класса этой эквивалентности индуцированный им подграф называются компонентой связности графа . Граф называется связным, если он сам является связной компонентой, что эквивалентно тому, что в нём любые две вершины являются концами некоторой цепи.  
 
1.5 Определения моста, точки сочленения и компоненты связности графа  
 
Граф называется связным, если любые две его вершины соединены путем. Компонента связности графа G — максимальный (по включению) связный подграф графа G. Ориентированный граф называется сильно связным, если две его произвольные вершины сильно связны. Две вершины i и j любого графа сильно связны, если существует ориентированный путь из i в j и ориентированный путь из j в i. Компонентами сильной связности орграфа называются его максимальные по включению сильно связные подграфы. 
Вершина i графа G является точкой сочленения в том случае, если граф G- i  состоит из большего числа компонент связности, чем G. Если граф G связный, то граф G- i   будет содержать по крайней мере две компоненты связности, то есть будет не связным. Исходя из этого определения изолированная вершина графа не может быть точкой сочленения. Граф, состоящий из одной вершины зовется тривиальным. Тривиальный граф не может иметь точек сочленения. Связный граф, не имеющий точек сочленения зовется неразделимым графом (не связный граф так же может быть разделимым). На рисунке 5 приводится пример разделимого графа с тремя точками сочленения. 
 
Рисунок 5 – Пример разделимого графа с тремя точками сочленения: 1, 2 и 
3 
Блоком разделимого графа G зовется максимальный неразделимый подграф графа G. На рисунке 6 приводится пример графа, разбитого на блоки. 
 
Рисунок 6 – Блоки графа 
Мостом называется такое ребро графа G, при удалении которого, количество компонент связности графа G возрастает. На рисунке 5 мостом будет ребро 2 – 3. 
 
1.6 Модель Random Waypoint 
Мобильные системы характеризуются движением своих компонентов. Характер движения составляющих мобильной системы — их скорость, направление и скорость изменения — может сильно повлиять на протоколы и системы, предназначенные для поддержки мобильности. К сожалению, движение в физическом мире часто неповторимо. На практике реальное использование мобильной системы может обеспечить осмысленное понимание, но не может служить единственным основанием для оценки эксперимента. Вместо этого сообщество мобильных устройств перешло к моделированию движения узлов и пользователей. Разумеется, для моделирования такой модели необходимо получить модель движения. Самой распространенной из них является модель Random Waypoint. Это одна из наиболее популярных моделей перемещения узлов в сети, в силу своей простоты и доступности. В Random Waypoint Model узлы движутся по сети беспорядочно и свободно со случайной скоростью в любой момент времени в случайном направлении. Эта модель была впервые предложена Джонсоном и Мальцем в оценке протокола маршрутизации для MANET с топологией mesh Dynamic Source Routing (DSR), и позже была подтверждена той же исследовательской группой. Переработанная версия этой модели и стала стандартом де-факто в исследованиях мобильных устройств. Например, десять работ в ACM MobiHoc 2002 рассматривали мобильность узлов, а девять из них использовали модель Random Waypoint. 
Как уже упоминалось, в модели Random Waypont узлы могут свободно перемещаться случайным образом в любом месте области моделирования сети независимо друг от друга. Это по сути означает, что для них нет какихлибо ограничений. Существует лишь случайный выбор точки назначения, скорости движения узла, направления движения и величины пауз между изменениями в направлении и скорости. Случайный выбор значений для перечисленных выше величин происходит из определенных заранее заданных числовых диапазонов. Моделирование начинается с задания величины паузы и, собственно, паузы всех узлов. После того, как мобильный узел «простоит» на месте в течение определенного периода времени (имеется в виду величина ранее заданной для него паузы), для него выбирается случайная точка назначения в пределах области моделируемой сети и случайная скорость, после чего он продолжает двигаться в направлении вновь выбранной цели с выбранной скоростью. По достижении места назначения, мобильный узел приостанавливается на определенный период времени перед повторным запуском того же самого процесса вновь. Здесь, скорость и время паузы оказывают влияние на подвижность узлов. Низкая скорость и долгое время паузы приводят к получению более стабильных топологии моделируемой сети, тогда как высокая скорость и короткое время паузы к более динамической топологии сети. На рисунке 7 иллюстрируется поведение узла в сети с моделью движения Random Waypoint. 
 
Рисунок 7 – Схема поведения узла в модели Random Waypoint 
 
Алгоритм, реализующий модель Random Waypoint может быть описан в следующие пять шагов: 
а) выбираем случайное место назначения в области моделируемой сети; 
б) выбираем величину скорости (равномерная распределенная); 
в) двигаем узел до тех пор, пока цель не будет достигнута им; 
г) выжидаем величину паузы (равномерное распределение); 
д) переходим к шагу 1. 
1.7 Известные проблемы модели Random Waypoint 
Всякая модель имеет определенные достоинства и недостатки, Random Waypoint не стала исключением из этого правила. Часто модель описывается как имеющая средняя скорость   — просто потому, что скорости узла выбираются из равномерного распределения (0, Vmax) — или некоторого значения между 0 и Vmax, если мы рассматриваем время положительной паузы. Ожидается, что эта модель будет поддерживать эту среднюю скорость по мере развития симуляции, а результаты моделирования почти всегда будут в виде среднего за определенный период времени. Такие средние показатели имеют смысл только в том случае, если имитация достигает устойчивого состояния. К сожалению, это не так. Дело в том, что по мере моделирования с течением времени набор узлов перемещается все медленнее. Все больше узлов «застревает» на больших расстояниях на малых скоростях. Таким образом, модель не может обеспечить устойчивое состояние с точки зрения средней скорости. Накладные расходы и производительность мобильных систем обычно сильно зависят от мобильности узлов. В свете этого случайная точка пути может генерировать вводящие в заблуждение или неверные результаты. В частности, со временем средние результаты сильно меняются; Чем дольше запускается симуляция, тем больше отклоняются дальнейшие результаты. Существует много способов исправить модель. Один простой способ – ограничить минимальную скорость, а также максимальную.  
 	 
Практическая реализация 
Среда разработки 
В качестве среды разработки была выбрана Java 8, JDK 1.8.0. Язык Java просто устроен и довольно удобен для разработки любых программ для решения практически любых задач. Простота устройства кода позволяет эффективно и легко писать, компилировать и отлаживать код программы.  
Так как Java является объектно-ориентированным языком, даже в большей степени, чем C++ (почти все сущности языка являются объектами, за исключением некоторых типов), то существует возможность создавать удобно устроенные модульные программы, легко встраивать любые решения, в уже готовый проект, а так же эффективно устраивать организацию программных блоков, с логической точки зрения на решаемую задачу.  
Одним из наиболее важных достоинств Java является кроссплатформен ность, программы, написанные на Java не зависят от платформы как на уровне исходного кода, так и на двоичном уровне, что позволяет запускать их на разных системах. Это достигается за счет перевода написанного кода в специальный байт-код и последующего его выполнения Java-машиной. Так же несомненный плюсом Java является возможность намного более легкой и простой разработки программ, которые не содержат скрытых ошибок, чем на том же C++. Создателями языка анализировались, так называемые «узкие места» исходного кода программ на C++, вследствие чего были выявлены проблемы, которые приводят к появлению ошибок, которые достаточно трудно выявить. Как следствие, проектирование языка Java было организовано таким образом, что появление скрытых ошибок в коде сведено практически к нулю. Для этого были приняты такие меры, как отсутствие в языке Java указателей, множественного наследования, которое было заменено интерфейсами, неявные преобразования типов с потерей точности, исключено явное выделение памяти, как следствие, программист не должен очищать память «руками», за него это сделает сборщик мусора, который специально предназначен для очищения не используемых областей памяти.  
Таким образом получаем еще один крупный плюс. Программист застрахован от ошибок, связанных с неверной работой с памятью. Так же в языке присутствует строгая типизация и обязательный контроль исключений (исключительных ситуаций). Множество логических ошибок будет обнаружено еще на этапе компиляции. Многие задачи, которые возникают при разработке программного обеспечения уже реализованы и существуют в качестве стандартных библиотек, что позволяет использовать множестве удобных решений и коллекций.  
Так же для языка существует просто огромное количество бесплатных библиотек, которые дают множество возможностей программисту. Так же стоит упомянуть явные плюсы и достоинства Intellij IDEA, на которой писался код программы. Главная вещь, отличающая IDEA, это понимание контекста. Именно это имеют в виду сотрудники JetBrains, когда называют свой продукт «интеллектуальным» (intelligent). Дело в том, что IDEA индексирует весь проект, анализирует всё, что в нём есть, и даже строит синтаксическое дерево. Благодаря этому IDEA в любой момент, куда бы не был поставлен разработчиком курсор, знает, в каком конкретно участке кода мы находимся и что тут происходит. Умение понимать контекст выражается в довольно многих аспектах, но наиболее полезными такие возможности являются при отладке кода, так как мы можем видеть значения переменных или выражений, при автозаполнении, потому как Idea всегда предложит программисту именно нужное имя метода, переменной, параметра функции и так далее, а так же при рефакторинге, потому как IDEA учитывает название метода, тип переменной, значение, названия подобных переменных в других местах программы, и те названия, которые программист давали подобным переменным ранее.  
IDEA действительно является мощнейшим редактором исходного кода. Здесь есть классические подсветки синтаксиса и несколько буферов обмена. Переходы к определению, автоматическое добавление нужных импортов, а также оптимизация импортов с удалением ненужных, встроенное отображение документации и типов, подсказка по аргументам, переименование аргументов, переменных и модулей буквально за секунду, быстрое указание возвращаемого типа у метода, множество подсказок, всплывающих в ходе написания кода, даже существует автоисправление кода. 
 
Представления графов в практической реализации 
 
Алгоритмические проблемы, рассматриваемые ниже, описываются входом, как правило, состоящим из нескольких графов (или перестановок) того или иного типа, и выходом, который описывается предикатом (для проблем распознавания) или несколькими графами или же перестановками. Для заданного входа алгоритм совершает некоторое количество элементарных операций в течение заданного времени и завершает работу, создавая выход предписанного типа. Количество элементарных операций в худшем случае именуется далее сложностью алгоритма. Вход и выход имеют длину которая, грубо говоря, равна размеру памяти, в которой он может быть записан. Поэтому сложность алгоритма является функцией длины входа. Алгоритм имеет полиномиальную сложность (работает полиномиальное время), если существует полином ( ) такой, что сложность алгоритма на входе длины  не превосходит ( ); в этом случае также говорят, что сложность алгоритма есть (1). Граф  = ( , ) на входе алгоритма может быть задан с помощью списка рёбер(инцидентности) и тогда вклад в длину входа равен длине этого списка 2| | = ( 2), где  = | |. На рисунке 8 приводится в качестве примера скриншот из программы, где граф, задан в виде списка инцидентности.  
 
 

Рисунок 8 – Граф, заданный списком инцидентности 
 
 Другой способ состоит в задании матрицы смежности  = ( ) графа , т.е. квадратной  ×  матрицы, определяемой формулой 2 следующим образом:  
 
	Auv  =  	                                  (2) 
 
В этом случае вклад в длину входа равен 2. Произвольная биекция : 
1 → 2 задаётся множеством пар ( ,  ); её вклад в длину входа считается равным 2| 1|. На рисунке 9 приводится скриншот, который изображает пример программного представления графа в виде матрицы смежности. 
 
Рисунок 9 – Граф, заданный матрицей смежности 
 
Оценка сложности решений поиска мостов, точек сочленения и компонент связности, приведенных в программе 
 
Поиск точек сочленения, так же как и мостов, наряду с поиском пути из узла в узел основаны на алгоритме обхода геометрического графа в глубину, сложность которого может быть оценена как O(n+m), где n — количество вершин, m — рёбер. Алгоритм Тарьяна, использовавшийся для поиска сильных компонент связности имеет подобную сложность(O(n+m)). 
 
Структура программы 
Основные блоки программы 
В ходе реализации программы, имитирующей ad hoc сеть с моделью движения узлов Random Waypoint был создан главный класс Network, а так же еще семь классов (два основных: Node – для узлов сети, Destination_Point – для точек назначения и пять дополнительных: Pair_Of_Components – для хранения пар компонент связности, Bridge – для мостов, Answer – для типа 
связи 	между 	узлами, 	Way 	– 	для 	путей 	между 	узлами 	и Time_Of_Existence_And_Absence_Of_A_Routes – для времен существования и отсутствия маршрутов из каждого узла в каждый).  
Полями класса Network являются переменные для количества узлов quantity_nodes и границ сети border_network, границ скоростей узлов border_min_speed и border_max_speed, радиусов узлов border_min_radius и border_max_radius, верхней границы пауз узлов border_max_pause, так же логические поля для обозначения характеристик геометрического графа сети(связный или нет, ориентированный или нет) is_oriented и is_connected, список узлов сети nodes с элементами класса Node, матрица смежности matrix_of_links(содержит сведения о связях между узлами сети), версия матрицы смежности(содержит все ребра графа сети, за исключением лишь ребер, которые связывают слабо связные вершины) для алгоритма поиска точек сочленения и кандидатов среди ребер геометрического графа моделируемой сети в мосты version_matrix_of_links_for_algorithm_finding_ connection_points_and_bridges и их размерность quantity_nodes (количество узлов), а так же список смежности list_adjacency, список для компонент связности графа connectivity_components, множество для точек сочленения connection_points, список для мостов bridges, список расстояний между компонентами связности графа distances_between_components и список словарей, содержащий времена существования и отсутствия маршрутов между узлами times. Так же в поля класса входят переменные для подсчетов средних значений при моделировании: компонент связности, мостов, точек сочленения, времен существования маршрутов и отсутствия маршрутов между заданной парой узлов, расстояния между компонентами графа – connectivity_components_average_value, bridges_average_value, connection_ points_average_value, time_exist_of_the_route_average_value, time_not_exist_ of_the_route_average_value, distance_between_components_ average_value. В методы класса входят следующие функции: 



	- 	 	 
public Network(int border_network, int quantity_nodes, int border_min_
speed, int border_max_speed, int border_pause, int border_min_radius, int border_ max_radius) – конструктор класса, инициализирует поля принимаемыми значениями и запускает метод старта сети. Принимает в качестве параметров границу для сети, количество узлов, границы для скорости, границу для паузы, границы для радиуса; 
* private void Initialize_Matrix_Of_Links() – функция инициализирует матрицу связей; 
* private void Initialize_Times_Of_Existence_And_Absence_Of_A_ Routes() – функция инициализирует список словарей, который содержит времена существования и отсутствия маршрутов из каждого узла в каждый; 
* private void Network_Start() – функция "запускает" сеть – создаются, инициализируются начальными значениями и активируются узлы; 
* private void Control_Node(Node node) – функция осуществляет управление поданным узлом. Принимает экземпляр класса узла; 
* private void Activate_Node(Node node) – функция активизации узла – задается случайная скорость, направление, пункт назначения и узел начинает движение. Принимает экземпляр класса узла; 
* private int Degree_Of_Vertex(int vertex) – функция определяет степень вершины. Принимает вершину геометрического графа(представление узла сети); 
* private Answer Check_The_Existence_Of_A_Link(double x1, double y1, double radius1, double x2, double y2, double radius2) – функция проверяет, есть ли соединение между узлами. Принимает координаты первого узла, радиус первого узла, координаты второго узла и радиус второго узла; 
* private void Generate_Matrix_Of_Link() – функция генерирует матрицу связей; 
* public void Show_Info_About_Current_Node(int index) – функция выводит информацию о указанном узле в консоль. Принимает индекс узла; 
* public void Show_Matrix_Of_Link() – функция выводит матрицу связей в консоль; 
* public void Show_Paths() – фукнция выводит в консоль информацию о путях от каждого узла к остальным; 
* private void Show_List_Adjacency() – функция выводит список смежности в консоль; 
* private void Show_Times_Exist_And_Absence_Of_A_Paths() – функция выводит список времен существования и отсутствия маршрутов между узлами в консоль; 
* private void Show_Connection_Point() – функция выводит список точек сочленения в консоль; 
* private void Show_Bridges() – функция выводит список мостов в консоль; 
* private void Define_The_Type_Of_Graph_By_The_Orientation_ 
Characteristic() – функция определяет ориентированный ли у нас геометрический граф или нет; 
* private void Define_The_Type_Of_Graph_By_The_Connectivity_ 
Characteristic() – функция определяет связный ли у нас геометрический граф или нет; 
* private void Update_Paths() – функция обновляет информацию о путях из каждого узла в остальные; 
* private boolean Way_Is_Exist(int v1, int v2) – функция-обертка для функции поиска в глубину (DFS). Принимает вершину из которой ищем путь и вершину, в которую ищем путь; 
* private Double Find_Distance_Between_Nodes(int index_node_1, int index_node_2) – функция возвращает длину пути(ребра) между 
узлами(вершинами). Принимает индексы узлов; 
private boolean DFS(int v1, int v2, boolean[] used, Way way) – функция
проверяет наличие пути из вершины v1 в вершину v2. Принимает номера вершин, массив уже посещенных вершин и экземпляр класса пути. Возвращает истину или ложь в зависимости от существования пути и так же попутно в ходе своей работы записывает в поля класса пути пройденные расстояния и посещенные вершины (так же происходит их удаление, так называемые откаты, если поиск пути производился в неверном направлении и в итоге пришли в такую вершину, из которой невозможно продолжать пути в указанную); 
* private void Initialize_Version_Matrix_Of_Links_For_Algorithm_ Finding_Connection_Points_And_Bridges() - функция инициализирует версию матрицы связей для алгоритма поиска точек сочленения и кандидатов в мосты ориентированного геометрического графа сети; 
* private Void Find_Connection_Point() – функция-обертка для модифицированной функции поиска в глубину (DFS_Modified); 
* private void DFS_Modified(int x, int parent, int[] number, int[] low, int counter) – функция ищет точки сочленения и кандидатов в мосты в геометрическом графе сети; 
* private void Find_Bridges() – функция ищет мосты в геометрическом графе сети; 
* private void Find_Connectivity_Components() – функция-обертка для функции dfs; 
* private dfs(int v, boolean[] used, ArrayList<Integer> comp) – функция ищет компоненты связанности в геометрическом графе сети; 
* private void Find_Strongly_Connectivity_Components() – функцияобертка для алгоритма Тарьяна; 
* private void Tarjan_Algorithm(Integer v, Boolean used[], HashMap 
<Integer, ArrayList<Integer>> result, Integer id, Integer lowlinks[], Integer indices[], ArrayDeque<Integer> stack) – поиск в глубину, приспособленный под нахождение сильных компонент связности в геометрическом графе сети; 
* private void Show_Results(HashMap<Integer, ArrayList<Integer>> map) – функция выводит в консоль компоненты связности. Принимает словарь с результатами поисков; 
* private double Find_Minimum_Distance(ArrayList<Integer> component_i, ArrayList<Integer> component_j) – функция находит минимальное расстояние между двумя компонентами геометрического графа сети. Принимает списки компонент связности; 
* private void Find_Distance_Between_Components() – функция ищет расстояния между всеми компонентами связности геометрического графа сети; 
* private static Network Read_Input_Data() – функция производит считывание входных данных с консоли; 
* private void Network_Work(int time, int interval) – функция работы сети. 
Принимает время, в течение которого должна происходить имитация. 
Полями класса Node являются переменные для координат узла на плоскости по оси абсцисс и оси ординат x и y, скорости speed, паузы pause, радиуса radius, логические переменные для обозначений состояний узла на текущий момент времени(находится ли узел в движении к случайно заданной точке, достиг ли узел пункта назначения и ожидает паузы, узел находится в состоянии паузы или же пауза истекла и узел готов к новой отправке) in_move, paused, time_pause_is_over, переменная для объекта класса точки назначения(Destination_Point), переменные для расстояния до пункта назначения и уже пройденного расстояния distance и distance_traveled, для времени count_steps, необходимого на путь до пункта назначения, смещений по оси абсцисс и ординат в момент времени offset_x и offset_y и словаря с путями для конкретного узла к другим узлам ways. В методы класса входят следующие функции: 
 public Node(int speed, double radius) – конструктор класса, принимает на
вход скорость для узла и радиус; 
* public void Set_Coordinates(double x, double y) – функция задает координаты узла на плоскости. Принимает значения координат; 
* public void Set_Speed(int speed) – функция задает скорость узла; 
* public double Get_X() – функция возвращает координату узла на плоскости по оси абсцисс. Принимает значение скорости; 
* public double Get_Y() – функция возвращает координату узла на плоскости по оси ординат; 
* public int Get_Speed() – функция возвращает значение скорости узла; 
* public double Get_Radius() – функция возвращает значение радиуса узла; 
* public int Get_Pause() – функция возвращает текущее значение паузы узла; 
* HashMap<Integer, Way> Get_Ways() – функция возвращает словарь, хранящий пути от этого узла к другим; 
* public void Assign_Pause (int pause) – функция задает узлу значение паузы. Принимает значение паузы; 
* public void Pause() – функция "паузит" узел; 
* public boolean Time_Pause_Is_Over() – функция возвращает значение логической переменной time_pause_is_over(истекло ли время паузы); 
* public boolean In_Move() – функция возвращает значение логической переменной in_move(находится ли узел в движении); 
* public boolean Paused() – функция возвращает значение логической переменной paused(находится ли узел в состоянии паузы); 
* public void Calculating_Parameters_Of_Movement(Destination_Point destination_point) – функция рассчета параметров движения узла. Принимает экземпляр класса точки назначения. Производит расчет параметров движения узла: времени движения, расстояния до точки назначения и смещений для узла в момент времени; 
* public void Move() – функция движения узла. Осуществляет движение узла в сети (по плоскости), смещая его на заранее высчитанные величины в каждый момент времени и контролирует, чтобы узел не «пролетел» точку назначения. 
Полями класса Destination_Point являются переменные для координат точки на плоскости x и y и переменная для объекта класса Random. В методы класса входят следующие функции: 
* public Destination_Point(int border_network) – конструктор класса, принимает границу сети; 
* public int Get_X() – функция возвращает координату узла на плоскости по оси абсцисс; 
* public int Get_Y() – функция возвращает координату узла на плоскости по оси ординат. 
Полями класса Pair_Of_Components являются переменные для списков компонент связности component_1 и component_2. В методы класса входят следующие функции: 
* public Pair_Of_Components(ArrayList<Integer> component_1, ArrayList <Integer> component_2) – конструктор класса, принимает списки с компонентами связности геометрического графа сети; 
* public ArrayList<Integer> Get_Component_1() – функция возвращает первую компоненту пары; 
* public ArrayList<Integer> Get_Component_2() – функция возвращает вторую компоненту пары. 
Полями класса Bridge являются переменные для вершин – «опор» моста vertex_1(начало моста) и vertex_2(конец моста). В методы класса входят следующие функции: 
 public Brigde(int vertex_1, int vertex_2) – конструктор класса, принимает
на вход индексы вершин – «опор» моста; 
* public int Get_Vertex_1() – функция возвращает первую «опору» 
(начало) моста; 
* public int Get_Vertex_2() – функция возвращает вторую «опору» 
(конец) моста. 
Полями класса Answer являются переменные для типа соединения между узлами connection_type и для индекса вершины (требуется для уточнения при одностороннем виде соединения) number_of_vertexes. В методы класса входят следующие функции: 
* public Answer(String connection_type, int ...number_of_vertex) – конструктор класса, принимает на вход строку с типом соединения между узлами и индекс узла(при одном из типов соединения); 
* public String Get_Connection_Type() – функция возвращает тип соединения между узлами; 
* public int Get_Index_Of_Vertex() – функция возвращает номер узла для уточнения ответа функции проверки типа связи.  
Полями класса Way являются переменные для длины пути way_length, тип BigDecimal для вычислений с повышенной точностью и для списка вершин, составляющих путь. В методы класса входят следующие функции: 
* public 	Way(BigDecimal 	way_length, 	ArrayList<Integer> 	way) 	– конструктор класса, принимает длину пути и список вершин way; 
* public BigDecimal Get_Way_Length() – функция возвращает длину пути; 
* public ArrayList<Integer> Get_Way() – функция возвращает список вершин(путь); 
* public double Get_Time_Exist_Of_The_Route() – функция возвращает значение времени жизни пути; 
* public double Get_Time_Not_Exist_Of_The_Route() – функция возвращает значение времени отсутствия пути; 
* public void Increase_Way_Length(BigDecimal value) – функция увеличивает значение длины пути на поданную величину; 
* public void Increase_The_Time_Exist_Of_The_Route() – функция увеличивает значение времени жизни пути; 
* public void Increase_The_Time_Not_Exist_Of_The_Route() – функция увеличивает значение времени отсутствия пути; 
* public void Decrease_Way_Length(BigDecimal value) – функция уменьшает значение длины пути на поданную величину/ 
Полями класса Time_Of_Existence_And_Absence_Of_A_Routes являются переменные для времени существования и отсутствия маршрута time_exist_ of_the_route и time_not_exist_of_the_route. В методы класса входят следующие функции: 
* public Time_Of_Existence_And_Absence_Of_A_Routes() – конструктор класса; 
* public double Get_Time_Exist_Of_The_Route() – функция возвращает значение времени жизни пути; 
* public double Get_Time_Not_Exist_Of_The_Route() – функция возвращает значение времени отсутствия пути; 
* public void Increase_The_Time_Exist_Of_The_Route() – функция увеличивает значение времени жизни пути; 
* public void Increase_The_Time_Not_Exist_Of_The_Route() – функция увеличивает значение времени отсутствия пути. 
Ниже, на рисунках 10 и 11 приведем диаграмму классов, построенную в среде разработки проекта – IntellijIDEA, чтобы отобразить связи классов в проекте: 


 
 	37 	 
 
	- 	 	 
 
Рисунок 10 – Диаграмма классов проекта. Методы 
 
Рисунок 11 – Диаграмма классов проекта. Переменные 
 
Описание работы программы 
Была реализована имитация сети с моделью перемещения Random Waypoint. В начале работы программа принимает на вход значения для границы сети, количества узлов, для границ скоростей, максимальной паузы, радиусов узлов и время работы, затем начинается само моделирование. Создается экземпляр класса сети, создаются экземпляры класса узла в количестве заданном несколько ранее при вводе. Для каждого узла назначается пауза, и начинается общая работа программы, а именно: программа работает до тех пор, пока не истечет указанное время моделирования – в каждый момент времени она проходит в цикле по узлам и проверяет состояние каждого из них. Если узел находится в состоянии паузы, то всякий раз вызывается метод Pause(), который производит уменьшение текущего значения паузы на единицу внутри программного времени. Пауза истекает когда ее значение становится равно 0. Если узел закончил пребывание в состоянии паузы и готов к отправке, то ему назначаются случайная скорость из заданного при вводе диапазона, а так же выбирается случайным образом точка направления на плоскости.  
Далее происходит расчет параметров движения узла к заданной точке в сети: вычисляется расстояние до точки, вычисляется время движения, и смещения для координат узла в каждый момент времени. После окончания расчетов параметров передвижения узла к пункту назначения, происходит «активизация» узла, он начинает движение к цели. Пока узел находится в состоянии движения, всякий раз вызывается метод Move(), который производит увеличение(уменьшение, зависит от направления узла и местонахождения точки назначения на плоскости) координат узла на рассчитанное ранее смещение. Так же осуществляется контроль над случаем, когда скорость узла больше оставшегося расстояния до пункта назначения на плоскости. В этом случае перемещение узла происходит на оставшееся до назначенной точки расстояние. Таким образом гарантируется, что узел «не пролетит» точку назначения. Если узел достиг точки назначения, он вводится в состояние случайно выбранной из заранее заданного диапазона паузы.  
После инициализации всех узлов сети происходит составление матрицы связей (матрица смежности геометрического графа сети), составление списка смежности, проверка наличия и расчет путей между каждой парой вершин, поиск времени существования и отсутствия таких путей, определяется по радиусам узлов, ориентированный граф или нет (в случае одинаковых значений величин радиусов для всех узлов имеем неориентированный граф, если же радиусы разные – то ориентированный, с той оговоркой, что при некоторых редких случаях при разных значениях радиусов мы все же можем получить неориентированный граф, если в сети отсутствуют такие пары узлов, которые связаны ориентированным в одну сторону ребром (иначе можно говорить, что отсутствует второе ориентированное ребро, которое направлено в противоположную сторону), то есть имеют одностороннюю связь, а есть только пары не связанных узлов и пары узлов, которые связаны двусторонней связью, то есть радиусы обоих узлов в конкретной паре больше расстояния между узлами), происходит поиск компонент связности для графа (компоненты в случае неориентированного и компоненты сильной связности в случае ориентированного графа), далее по количеству найденных компонент связности геометрического графа сети определяется связный граф или нет. В случае если наш геометрический граф не связен, есть необходимость найти расстояния между всеми его компонентами. Помимо перечисленных выше процедур, происходит так же поиск точек сочленения и мостов в геометрическом графе сети с предварительным составлением копии матрицы связей геометрического графа (в случае ориентированного графа нам необходимо учитывать лишь сильную связность, поэтому все ребра, связывающие слабо связные вершины исключаются из матрицы смежности).  
 
Анализ результатов 
Были проведены десять тысяч испытаний на случайных геометрических графах. Каждое испытание длилось десять тысяч тиков времени (внутри программное время). Размер сети 500 x 500. Количество узлов в сети 100. 
Радиус узлов в диапазоне [25, 50]. Сначала диапазоны скоростей узлов были постоянны: [25, 50], [50, 75], [75, 100], [100, 125], [125, 150], [150, 175], [175, 200], [200, 225], [225, 250], а верхняя граница для паузы узлов увеличивалась с шагом 5, от 5 до 55 соответственно. Были выявлены следующие зависимости: 
При постоянной скорости узлов и увеличении максимальной верхней границы для паузы, количество компонент связности, точек сочленения и мостов в графе увеличивалось. Данные зависимости видны на графиках (рисунки 12 – 18): 
 
 
0
 
1
 
2
 
3
 
4
 
5
 
6
 
7
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество компонент
 
Максимальная пауза узлов
 

Рисунок 12 – График зависимости среднего количества компонент связности от паузы узлов. Скорость узлов в диапазоне от 25 до 50 
 
Мы можем увидеть, что ситуация подобна для всех постоянных диапазонов скоростей: 
 
0
 
5
,
0
 
1
 
5
1
,
 
2
 
5
,
2
 
3
 
5
,
3
 
4
 
5
,
4
 
5
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество компонент
 
Максимальная пауза узлов
 

Рисунок 13 – График зависимости среднего количества компонент связности 
от паузы узлов. Скорость узлов в диапазоне от 50 до 75 
 
 
0
 
1
 
2
 
3
 
4
 
5
 
6
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество 
компонент
 
Максимальная пауза узлов
 

Рисунок 14 – График зависимости среднего количества компонент связности 
от паузы узлов. Скорость узлов в диапазоне от 75 до 100 
 
0
 
5
,
0
 
1
 
5
1
,
 
2
 
5
,
2
 
3
 
5
,
3
 
4
 
5
,
4
 
5
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество компонент
 
Максимальная пауза узлов
 

Рисунок 15 – График зависимости среднего количества компонент связности 
от паузы узлов. Скорость узлов в диапазоне от 100 до 125 
 
И так далее, приведем график для последнего набора из данной серии замеров: 
 
0
 
1
 
2
 
3
 
4
 
5
 
6
 
7
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество 
компонент
 
Максимальная пауза узлов
 

Рисунок 16 – График зависимости среднего количества компонент связности от значения узлов. Скорость узлов в диапазоне от 225 до 250 
 
0
 
5
,
0
 
1
 
1
5
,
 
2
 
2
,
5
 
3
 
5
,
3
 
4
 
5
,
4
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество точек 
сочленения и мостов
 
Максимальная пауза узлов
 
Точки сочленения
 
Мосты
 

Рисунок 17 – График зависимости среднего количества точек сочленения и мостов от значения паузы у узлов. Скорость узлов в диапазоне от 25 до 50 
 
Ситуация тут, как и с графиками выше повторяется, количество возрастает на всех диапазонах скоростей. Приведем график для последнего диапазона скоростей: 
 
0
 
1
 
2
 
3
 
4
 
5
 
6
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее количество точек 
сочленения и мостов
 
Максимальная пауза узлов
 
Точки сочленения
 
Мосты
 

Рисунок 18 – График зависимости среднего количества точек сочленения и мостов от значения паузы узлов. Скорость узлов в диапазоне от 225 до 250 Зависимость для количества компонент связности, точек сочленения и мостов от скорости узлов не была выявлена. 
Перейдем теперь к рассмотрению времени жизни маршрута и времени его отсутствия. При постоянной скорости узлов и увеличении максимальной верхней границы для паузы, время существования маршрута между парой узлов уменьшалось, а время отсутствия маршрута, напротив, увеличивалось, что будет видно на графиках 19 – 27: 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время жизни маршрута
 
Максимальная пауза узлов
 

Рисунок 19 – График зависимости среднего времени жизни маршрута от значения паузы узлов. Скорость узлов в диапазоне от 25 до 50 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время жизни маршрута
 
Максимальная пауза узлов
 

Рисунок 20 – График зависимости среднего времени жизни маршрута от значения паузы узлов. Скорость узлов в диапазоне от 50 до 75 
 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время жизни маршрута
 
Максимальная пауза узлов
 

Рисунок 21 – График зависимости среднего времени жизни маршрута от значения паузы узлов. Скорость узлов в диапазоне от 75 до 100 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время жизни маршрута
 
Максимальная пауза узлов
 

Рисунок 22 – График зависимости среднего времени жизни маршрута от значения паузы узлов. Скорость узлов в диапазоне от 225 до 250 
 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
200
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время отсутствия 
маршрута
 
Максимальная пауза узлов
 

Рисунок 23 – График зависимости среднего времени отсутствия маршрута от значения паузы узлов. Скорость узлов в диапазоне от 25 до 50 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время отсутствия 
маршрута
 
Максимальная пауза узлов
 

Рисунок 24 – График зависимости среднего времени отсутствия маршрута от значения паузы узлов. Скорость узлов в диапазоне от 50 до 75 
 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время отсутствия 
маршрута
 
Максимальная пауза узлов
 

Рисунок 25 – График зависимости среднего времени отсутствия маршрута от значения паузы узлов. Скорость узлов в диапазоне от 75 до 100 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время отсутствия 
маршрута
 
Максимальная пауза узлов
 

Рисунок 26 – График зависимости среднего времени отсутствия маршрута от значения паузы узлов. Скорость узлов в диапазоне от 100 до 125 
 
Приведем график с последним диапазоном скорости (рисунок 26): 
 
0
 
20
 
40
 
60
 
80
 
100
 
120
 
140
 
160
 
180
 
0
 
10
 
20
 
30
 
40
 
50
 
60
 
Среднее время отсутствия 
маршрута
 
Максимальная пауза узлов
 

Рисунок 27 – График зависимости среднего времени отсутствия маршрута от значения паузы узлов. Скорость узлов в диапазоне от 225 до 250 
Теперь рассмотрим зависимость средней длины маршрута между парой вершин в зависимости от значений скорости. Паузы были постоянны. Как будет видно из графиков ниже (Рисунки 28 – 30), средняя длина маршрута будет расти с увеличением скорости узлов. 
 
 
0
 
100
 
200
 
300
 
400
 
500
 
600
 
0
 
50
 
100
 
150
 
200
 
250
 
300
 
Средняя длина маршрута
 
Скорость узлов
 

Рисунок 28 – График зависимости средней длины маршрута между парой узлов от значения скорости узлов. Максимальная пауза 5 
 
0
 
50
 
100
 
150
 
200
 
250
 
300
 
350
 
400
 
450
 
500
 
0
 
50
 
100
 
150
 
200
 
250
 
300
 
Средняя длина маршрута
 
Скорость узлов
 

Рисунок 29 – График зависимости средней длины маршрута между парой узлов от значения скорости узлов. Максимальная пауза 10 
 
 
Рисунок 30 – График зависимости средней длины маршрута между парой узлов от значения скорости узлов. Максимальная пауза 55 ЗАКЛЮЧЕНИЕ 
Во время выполнения дипломной работы была изучена и сымитирована модель движения Random Waypoint. Были произведены сравнения различных характеристик сети в разные моменты времени с разными диапазонами значений для скоростей и пауз узлов и сделаны выводы. Ясно, что значение пауз узлов оказывает влияние на такие параметры сети, как количество точек сочленения, мостов, компонент связности, а так же на время жизни маршрута между парой узлов и время отсутствия маршрута между парой узлов. Скорость узлов оказывает влияние на среднюю длину маршрута между парой узлов. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ 
1.  Зыков А. А.  Основы теории графов. // М.: Наука, 1986. — 456 с. 
2.  Белов В.В., Воробьев Е.М., Шаталов В.Е. Теория графов. // М.: 
Высш.шк., 1976. — 392 с. 
3.  Емеличев В.А., Мельников О.И., [и др.] Лекции по теории графов. // М.: Наука, 1990. — 384 с. 
4.  МАРШРУТИЗАЦИЯ В БЕСПРОВОДНЫХ МОБИЛЬНЫХ AD HOC-
СЕТЯХ [Электронный ресурс]. URL: http://cyberleninka.ru/article/n/marshruti zatsiya-v-besprovodnyh-mobilnyh-ad-hoc-setyah (дата обращения: 06.02.2017). 
5.  Оре О. Графы и их применение. // М.: URSS, 2006. — 268 с. 
6.  Миков А.И., Мезенцева А.С. Характеристики геометрических графов, моделирующих AD HOC сети // Информатизация и связь. — 2012. — № 5. — с. 85—88. 
7.  Харари Ф. Теория графов. М.: Эдиториал УРСС, 2003. 
8.  Что такое MANET или почему WiFi не решение всех телекоммуникационных проблем [Электронный ресурс]. URL: https://habrahabr.ru/post/197860/ (дата обращения: 01.04.2017). 
9.  Random Waypoint Considered Harmful [Электронный ресурс]. URL: http://web.eecs.umich.edu/~mingyan/pub/infocom03.pdf (дата обращения: 
06.02.2017). 
10.  Random Waypoint [Электронный ресурс]. URL: http://www.routingprotokolle.de/Routing/mobility_random_waypoint.htm (дата обращения: 07.05.2017). 
 
 
 
 
ПРИЛОЖЕНИЕ А 
Код программы 
 
import java.io.*; import java.math.BigDecimal; 
import java.util.*; 
 
/** 
 * Created by Vitalik on 06.03.2017. 
 */ 
 
public class Network 
{     private int border_network; /** Верхняя граница для размеров сети(Random) 
**/ 
    private int quantity_nodes; /** Количество узлов **/     private int border_min_speed; /** Нижняя граница для скорости(Random) **/     private int border_max_speed; /** Верхняя граница для скорости(Random) 
**/     private int border_max_pause; /** Верхняя граница для паузы(Random) **/     private int border_min_radius; /** Нижняя граница для радиуса(Random) **/     private int border_max_radius; /** Верхняя граница для радиуса(Random) **/     private boolean is_oriented; /** ориентированный граф или нет **/     private boolean is_connected; /** Граф связный или нет(Имеет ли ровно одну компоненту связности) **/ 
    private ArrayList<Node> nodes = new ArrayList<Node>(); /** Список узлов сети **/     private ArrayList<ArrayList<String>> matrix_of_links; /** Содержит информацию о наличии соединения между узлами "-" - соединения нет,     "tw" - соединение двусторонее, "ow" - соединение односторонее (матрица смежности)**/ 
    private ArrayList<ArrayList<String>> version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges; 
/** Версия матрицы смежности для алгоритма поиска точек сочленения и мостов(Будут исключены все ребра(односторонние), которые соединяют слабо связные вершины) **/     private HashMap<Integer, ArrayList<Integer>> list_adjacency = new HashMap<Integer, ArrayList<Integer>>(); /** Список смежности **/     private HashMap<Integer, ArrayList<Integer>> connectivity_components = new HashMap<Integer, ArrayList<Integer>>(); /** Список компонент связности 
**/
    private HashSet<Integer> connection_points = new HashSet<>(); /** Содержит точки сочленения **/ 
    private ArrayList<Brigde> bridges = new ArrayList<Brigde>(); /** Содержит мосты **/ 
    private HashMap<Pair_Of_Components, Double> distances_between_components = new HashMap<Pair_Of_Components, Double>(); /** Содержит расстояние между компонентами связности **/     private ArrayList<HashMap<Integer, 
Time_Of_Existence_And_Absence_Of_A_Routes>> times; /** Хранит время жизни маршрутов и время отсутствия маршрутов из этого узла в другие. Формат: Ключ - номер узла, значение: объект вспомогательного класса с полями: time_exist_of_the_route – время существования маршрута и time_not_exist_of_the_route - время отсутствия маршрута **/     int connectivity_components_average_value;     int connection_points_average_value;     int bridges_average_value;     double distance_between_components_average_value;     double time_exist_of_the_route_average_value;     double time_not_exist_of_the_route_average_value; 
 
    private int Random(int min, int max) 
    { 
        max -= min; 
        return ((int) (Math.random() * ++max) + min); 
    } 
 
    public Network(int border_network, int quantity_nodes, int border_min_speed, int border_max_speed, int border_max_pause, int border_min_radius, int border_max_radius) 
    { 
        this.border_network = border_network;         this.quantity_nodes = quantity_nodes;         this.border_min_speed = border_min_speed;         this.border_max_speed = border_max_speed;         this.border_max_pause = border_max_pause;         this.border_min_radius = border_min_radius;         this.border_max_radius = border_max_radius;         is_connected = is_oriented = false;         connectivity_components_average_value = 0;         connection_points_average_value = 0;         bridges_average_value = 0;         distance_between_components_average_value = 0; 
        /*time_exist_of_the_route_average_value = 0;         time_not_exist_of_the_route_average_value = 0;*/ 
        Initialize_Matrix_Of_Links(); 
        //Initialize_Times_Of_Existence_And_Absence_Of_A_Routes();         Network_Start(); 
    } 
 
    /** Функция инициализирует матрицу связей **/ 
    private void Initialize_Matrix_Of_Links() 
    { 
        matrix_of_links = new ArrayList<ArrayList<String>>();         for (int i = 0; i < quantity_nodes; i++) 
        { 
            matrix_of_links.add(i, new ArrayList<String>()); 
            for (int j = 0; j < quantity_nodes; j++)                 matrix_of_links.get(i).add(j, "-"); 
        } 
    } 
 
    /** Функция инициализирует список словарей, который содержит времена существования и отсутствия маршрутов из каждого узла в каждый **/     private void Initialize_Times_Of_Existence_And_Absence_Of_A_Routes() 
    { 
        times = new ArrayList<HashMap<Integer, 
Time_Of_Existence_And_Absence_Of_A_Routes>>(); 
        for (int i = 0; i < quantity_nodes; ++i) 
        { 
            HashMap<Integer, Time_Of_Existence_And_Absence_Of_A_Routes> times_of_existence_and_absence_of_a_routes = new HashMap<Integer, 
Time_Of_Existence_And_Absence_Of_A_Routes>(); 
            for (int j = 0; j < quantity_nodes; ++j) 
            {                 if (i == j)                     continue; 
 
                Time_Of_Existence_And_Absence_Of_A_Routes time_of_existence_and_absence_of_a_routes = new Time_Of_Existence_And_Absence_Of_A_Routes(); 
                times_of_existence_and_absence_of_a_routes.put(j, 
time_of_existence_and_absence_of_a_routes); 
            } 
            times.add(times_of_existence_and_absence_of_a_routes); 
        } 
}
 
    /** Функция "запускает" сеть - создаются, инициализируются начальными значениями и активируются узлы **/     private void Network_Start() 
    { 
        for (int i = 0; i < quantity_nodes; i++) 
        { 
            Node node = new Node(Random(border_min_speed, border_max_speed), 
Random(border_min_radius, border_max_radius)); 
            node.Set_Coordinates(Random(0, border_network), Random(0, border_network)); 
            node.Assign_Pause(Random(0, border_max_pause));             nodes.add(node); 
        } 
    } 
 
    /** Функция осуществляет управление поданным узлом **/     private void Control_Node(Node node) 
    { 
        if (!node.In_Move() && !node.Paused()) /** Если узел не движется и не находится в состоянии паузы **/ 
        { 
                node.Assign_Pause(Random(0, border_max_pause)); 
        } 
 
        if (!node.In_Move() && node.Paused() && !node.Time_Pause_Is_Over()) 
/** Если узел не движется и находится в состоянии паузы **/ 
        { 
            node.Pause(); 
        } 
 
        if (!node.In_Move() && node.Paused() && node.Time_Pause_Is_Over()) /** 
Если узел не движется, находится в состоянии паузы и          готов к отправке(пауза истекла) **/ 
        { 
            Activate_Node(node); 
        } 
 
        if (node.In_Move()) /** Узел находится на пути к цели **/ 
        { 
            node.Move(); 
        } 
}
 
    /** Функция активизации узла - задается случайная скорость, направление, пункт назначения и узел начинает движение **/     private void Activate_Node(Node node) 
    { 
        node.Set_Speed(Random(border_min_speed, border_max_speed)); 
        Destination_Point destination_point = new Destination_Point(border_network); 
        node.Calculating_Parameters_Of_Movement(destination_point); 
    } 
 
    /** Функция проверяет, есть ли соединение между узлами **/     private Answer Check_The_Existence_Of_A_Link(double x1, double y1, double radius1, double x2, double y2, double radius2) 
    { 
        double distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); 
 
        if (radius1 > distance && radius2 > distance) 
        { 
            Answer answer = new Answer("connection two-way");             return answer; 
        }         else 
        { 
            if (radius1 > distance) 
            { 
                Answer answer = new Answer("connection one-way", 1);                 return answer; 
            } 
 
            if (radius2 > distance) 
            { 
                Answer answer = new Answer("connection one-way", 2);                 return answer; 
            } 
        } 
        Answer answer = new Answer("no connection");         return answer; 
    } 
 
    /** Функция генерирует матрицу связей **/     private void Generate_Matrix_Of_Link() {
        int index_i = 0;         for (Node node: nodes) 
        { 
            ArrayList<Integer> list = new ArrayList<>();             int index_j = 0;             for (Node unit : nodes) 
            { 
                if (index_j == index_i) 
                { 
                    index_j++;                     continue; 
                } 
 
                if (Check_The_Existence_Of_A_Link(node.Get_X(), node.Get_Y(), node.Get_Radius(), unit.Get_X(), unit.Get_Y(), 
unit.Get_Radius()).Get_Connection_Type().equals("no connection"))                     matrix_of_links.get(index_i).set(index_j, "-");                 else 
                    if (Check_The_Existence_Of_A_Link(node.Get_X(), node.Get_Y(), node.Get_Radius(), unit.Get_X(), unit.Get_Y(), 
unit.Get_Radius()).Get_Connection_Type().equals("connection two-way")) 
                    { 
                        matrix_of_links.get(index_i).set(index_j, "tw");                         list.add(index_j); 
                }                 else 
                    if (Check_The_Existence_Of_A_Link(node.Get_X(), node.Get_Y(), node.Get_Radius(), unit.Get_X(), unit.Get_Y(), 
unit.Get_Radius()).Get_Connection_Type().equals("connection one-way")) 
                    { 
                        matrix_of_links.get(index_i).set(index_j, "ow"); 
 
                        if (Check_The_Existence_Of_A_Link(node.Get_X(), node.Get_Y(), node.Get_Radius(), unit.Get_X(), unit.Get_Y(), unit.Get_Radius()).Get_Index_Of_Vertex() == 1) 
                            list.add(index_j); 
                    }                 index_j++; 
            } 
            list_adjacency.put(index_i, list);             index_i++; 
        } 
}
 
    /** Функция выводит информацию о указанном узле в консоль **/     public void Show_Info_About_Current_Node(int index) 
    { 
        System.out.println("Узел " + index + ":"); 
        System.out.println("Координаты: x = " + nodes.get(index).Get_X() + ", y = " + nodes.get(index).Get_Y()); 
        System.out.println("Скорость узла: " + nodes.get(index).Get_Speed()); 
        System.out.println("Текущее значение паузы узла: " + nodes.get(index).Get_Pause()); 
        System.out.println("Радиус узла: " + nodes.get(index).Get_Radius()); 
        System.out.print("Состояние на данный момент времени: "); 
 
        if (!nodes.get(index).In_Move() && !nodes.get(index).Paused()) /** Если узел не движется и не находится в состоянии паузы **/ 
        { 
            System.out.println("Узел достиг цели и ожидает значение паузы"); 
        } 
 
        if (!nodes.get(index).In_Move() && nodes.get(index).Paused() && !nodes.get(index).Time_Pause_Is_Over()) /** Если узел не движется и находится в состоянии паузы **/ 
        { 
            System.out.println("Узел находится в состоянии паузы"); 
        } 
 
        if (!nodes.get(index).In_Move() && nodes.get(index).Paused() && nodes.get(index).Time_Pause_Is_Over()) /** Если узел не движется, находится в состоянии паузы и готов к отправке(пауза истекла) **/ 
        { 
            System.out.println("Узел готов к отправке к новой цели"); 
        } 
 
        if (nodes.get(index).In_Move()) /** Узел находится на пути к цели **/ 
        { 
            System.out.println("Узел движется к цели"); 
        } 
        System.out.println(); 
    } 
 
    /** Функция выводит матрицу связей в консоль **/     public void Show_Matrix_Of_Link() {
        for (int i = 0; i < matrix_of_links.size(); i++) 
        { 
            for (int j = 0; j < matrix_of_links.size(); j++) 
                System.out.print(matrix_of_links.get(i).get(j) + " "); 
            System.out.println(); 
        } 
        System.out.println(); 
    } 
 
    /** Фукнция выводит в консоль информацию о путях от каждого узла к остальным **/ 
    private void Show_Paths() 
    { 
        System.out.println("Пути: ");         for (int i = 0; i < quantity_nodes; i++) 
        { 
            for (int j = 1 + i; j < quantity_nodes; j++) 
            { 
                System.out.print("Длина пути из узла " + i + " в узел " + j + ": " + 
nodes.get(i).Get_Ways().get(j).Get_Way_Length()); 
                if (nodes.get(i).Get_Ways().get(j).Get_Way().size() > 1) 
                { 
                    System.out.print(", Путь: "); 
                    for (int k = 0; k < +nodes.get(i).Get_Ways().get(j).Get_Way().size(); k++) 
                        if (k + 1 != nodes.get(i).Get_Ways().get(j).Get_Way().size()) 
                            
System.out.print(nodes.get(i).Get_Ways().get(j).Get_Way().get(k) + " -> ");                         else                             
System.out.print(nodes.get(i).Get_Ways().get(j).Get_Way().get(k)); 
                } 
                System.out.println(); 
            } 
            System.out.println(); 
        } 
        System.out.println(); 
    } 
 
    /** Функция выводит список смежности в консоль **/ 
    private void Show_List_Adjacency() 
    { 
        for (Integer i = 0; i < quantity_nodes; i++) 
        { 
            System.out.print("Узел " + i + " имеет связь с узлами: "); 
            for (int j = 0; j < list_adjacency.get(i).size(); j++)                 System.out.print(list_adjacency.get(i).get(j) + " "); 
            System.out.println(); 
        } 
        System.out.println(); 
    } 
 
    /** Функция выводит список времен существования и отсутствия маршрутов между узлами в консоль **/ 
    private void Show_Times_Exist_And_Absence_Of_A_Paths() 
    { 
        for (int i = 0; i < times.size(); ++i)             for (Map.Entry<Integer, 
Time_Of_Existence_And_Absence_Of_A_Routes> entry : times.get(i).entrySet()) 
            { 
                System.out.println("путь из " + i + " в " + entry.getKey() + " существовал: " + entry.getValue().Get_Time_Exist_Of_The_Route());                 System.out.println("путь из " + i + " в " + entry.getKey() + " не существовал: " + entry.getValue().Get_Time_Not_Exist_Of_The_Route()); 
            } 
        System.out.println(); 
    } 
 
    /** Функция выводит список точек сочленения в консоль **/     private void Show_Connection_Point() 
    { 
        for (Integer i: connection_points) 
            System.out.println(i); 
    } 
 
    /** Функция выводит список мостов в консоль **/ 
    private void Show_Bridges() 
    { 
        for (int i = 0; i < bridges.size(); i++) 
            System.out.println(bridges.get(i).Get_Vertex_1() + " - " + bridges.get(i).Get_Vertex_2()); 
    } 
 
    /** Функция определяет ориентированный ли у нас геометрический граф или нет **/ 
    private void 
Define_The_Type_Of_Graph_By_The_Orientation_Characteristic() 
    { 
        is_oriented = false;         for (int i = 0; i < matrix_of_links.size(); ++i)             for (int j = 0; j < matrix_of_links.size(); ++j)                 if (matrix_of_links.get(i).get(j).equals("ow")) 
                { 
                    is_oriented = true; 
                    break; 
                } 
    } 
 
    /** Функция определяет связный ли у нас геометрический граф или нет **/     private void 
Define_The_Type_Of_Graph_By_The_Connectivity_Characteristic() 
    { 
        if (connectivity_components.size() > 1) 
            is_connected = false;         else 
            is_connected = true; 
    } 
 
    /** Функция обновляет информацию о путях из каждого узла в остальные 
**/ 
    private void Update_Paths(int i, int j) 
    { 
        for (int i = 0; i < quantity_nodes; ++i) 
            for (int j = 0; j < quantity_nodes; ++j) 
            {                 if (j == i)                     continue; 
 
                if (Way_Is_Exist(i, j)) 
                    times.get(i).get(j).Increase_The_Time_Exist_Of_The_Route();                 else 
                    times.get(i).get(j).Increase_The_Time_Not_Exist_Of_The_Route(); 
           } 
    } 
 
    /** Функция-обертка для функции поиска в глубину (DFS) **/     private boolean Way_Is_Exist(int v1, int v2) 
    { 
        BigDecimal way_length = new BigDecimal(0.0); 
        ArrayList<Integer> list = new ArrayList<Integer>(); 
        Way way = new Way(way_length, list);         nodes.get(v1).Get_Ways().put(v2, way); 
        boolean[] used = new boolean[matrix_of_links.size()];         if (DFS(v1, v2, used, way)) 
            return true;         return false; 
    } 
 
    /** Функция возвращает длину пути(ребра) между узлами(вершинами) **/     private double Find_Distance_Between_Nodes(int index_node_1, int index_node_2) 
    { 
        double difference_between_coordinates_x = 
nodes.get(index_node_1).Get_X() - nodes.get(index_node_2).Get_X(); /** Катет(Ось абсцисс) **/ 
        double difference_between_coordinates_y = 
nodes.get(index_node_1).Get_Y() - nodes.get(index_node_2).Get_Y(); /** Катет(Ось ординат) **/ 
        double distance = Math.sqrt(Math.pow(difference_between_coordinates_x, 2) 
+ Math.pow(difference_between_coordinates_y, 2));         return distance; 
    } 
 
    /** Функция проверяет наличие пути из вершины v1 в вершину v2 **/     private boolean DFS(int v1, int v2, boolean[] used, Way way) 
    { 
        if (v1 == v2) 
            return true; 
 
        used[v1] = true; 
        for (int i = 0; i < matrix_of_links.size(); ++i) 
        { 
            if (!matrix_of_links.get(v1).get(i).equals("-") && !used[i]) 
            { 
                BigDecimal distance = new 
BigDecimal(Find_Distance_Between_Nodes(v1, i));                 way.Increase_Way_Length(distance); 
                way.Get_Way().add(i); 
 
                if (DFS(i, v2, used, way))                     return true;                 way.Decrease_Way_Length(distance);                 for (int j = 0; j < way.Get_Way().size(); ++j)                     if (way.Get_Way().get(j) == i) 
                    { 
                        way.Get_Way().remove(j);                         break; 
                    } 
            }         } 
        return false; 
    } 
 
    /** Функция инициализирует версию матрицы связей для алгоритма поиска точек сочленения и кандидатов в мосты ориентированного геометрического графа сети **/     private void 
Initialize_Version_Matrix_Of_Links_For_Algorithm_Finding_Connection_Points _And_Bridges() 
    {         
version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges = new ArrayList<ArrayList<String>>(); 
        for (int i = 0; i < quantity_nodes; i++) 
        {             
version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges.a dd(i, new ArrayList<String>()); 
            for (int j = 0; j < quantity_nodes; j++) 
                
version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges.g et(i).add(j, "-"); 
        } 
 
        for (int i = 0; i < matrix_of_links.size(); ++i)             for (int j = 0; j < matrix_of_links.size(); ++j) 
            { 
                if (matrix_of_links.get(i).get(j).equals("ow")) 
                    
version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges.g et(i).set(j, "-");                 else version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges.g et(i).set(j, matrix_of_links.get(i).get(j)); 
            } 
    } 
 
    /** Функция-обертка для модифицированной функции поиска в глубину 
(DFS_Modified) **/ 
    private void Find_Connection_Point() 
    { 
        if (is_oriented) 
            
Initialize_Version_Matrix_Of_Links_For_Algorithm_Finding_Connection_Points
_And_Bridges(); 
        else 
            
version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges = matrix_of_links; 
 
        connection_points.clear();         bridges.clear(); 
        int[] number = new int[quantity_nodes]; /** Массив, хранящий время обнаружения вершин **/ 
        int[] low = new int[quantity_nodes]; /** Минимум из значений d[x] и значений d[y] среди всех обратных ребер (z, y) **/         int counter = 1; 
        for (int x = 0; x < quantity_nodes; x++) 
            if (number[x] == 0) 
                DFS_Modified(x, -1, number, low, counter); 
    } 
 
    /** Функция ищет точки сочленения и кандидатов в мосты в геометрическом графе сети **/ 
    private void DFS_Modified(int x, int parent, int[] number, int[] low, int counter) 
    { 
        int kids = 0; 
        number[x] = low[x] = counter++;         for (int i = 0; i < 
version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges.s ize(); i++) 
            if 
(!version_matrix_of_links_for_algorithm_finding_connection_points_and_bridges.
get(i).get(x).equals("-")) 
            { 
                if (i != parent) 
                { 
                    if (number[i] == 0) 
 
 	37 	 
 
