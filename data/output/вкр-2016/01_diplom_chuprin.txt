Evaluation Warning: The document was created with Spire.Doc for Python.
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ 
Федеральное государственное бюджетное образовательное учреждение высшего образования 
«КУБАНСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ» (ФГБОУ ВО «КубГУ») 
 
Кафедра вычислительных технологий 
 
 
 	ДОПУСТИТЬ К ЗАЩИТЕ В ГЭК  	Заведующий кафедрой 
 	   д-р физ.-мат. наук, проф.  	 _________________ А.И. Миков. 
	 	(подпись)        (инициалы, фамилия) 
	 	________________________2016 г. 
 
 
 
ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА БАКАЛАВРА 
 
РАЗРАБОТКА СИСТЕМЫ МОДЕЛИРОВАНИЯ AD HOC СЕТЕЙ В 
НЕВЫПУКЛЫХ ОБЛАСТЯХ 
 
 
	Работу выполнил 	С. Ю. Чуприн 
Факультет компьютерных технологий и прикладной математики Направление 02.03.02 – Фундаментальная информатика и информационные технологии 
	Научный руководитель, преп.________  	 	 	     С.С. Ермоленко 
	Нормоконтролер  	 	 	 	 	 	 	 	 Ю.С. Фисун  
 
 
 
 
 
 
 

Краснодар 2016
РЕФЕРАТ 
 
Выпускная квалификационная работа содержит 42 страницы, 15 рисунков, 6 источников, 1 приложение. 
КЛИЕНТ-СЕРВЕР, AD-HOC СЕТИ, ANDROID, БД, МОБИЛЬНАЯ РАЗРАБОТКА, ПАРАЛЛЕЛЬНОЕ ПРОГРАММИРОВАНИЕ OPENMP 
Темой работы является разработка системы моделирования Ad-hoc сетей в невыпуклых областях 
Объектом исследования данной работы является клиент-серверная архитектура ПО, модели Ad-hoc сетей. 
Целью данной работы является построение клиент-серверной архитектуры для организации удаленных вычислений и статистического моделирования Ad-hoc сетей. 
Для исследования и решения поставленной задачи использованы: для реализации клиента выбрана среда программирования Android Studio 2.2, для тестирования были выбраны эмулятор Genymotion и реальное устройство Nexus 5. Для реализации серверной части Sublime Text 2 и БД MySQL, язык 
PHP, для разработки вычислительного ядра – программы, моделирующей Adhoc сети, была выбрана IDE Visual Studio, язык C++ и основные геометрические познания. 
 
 
 
 
 
 
 

СОДЕРЖАНИЕ 
Введение………………………………………………………………….      3 
1  Моделирование беспроводных Ad-hoc сетей………………………...     5 
1.1  Общие сведения о генерации сетей……………………………     5 
1.2  Общие сведения об анализируемых характеристиках ………     7 
2  Способы и технологии параллельного программирования………….     9 
2.1  Общие сведения о параллельном программировании………..     9 
2.2  Краткий обзор используемой параллельной технологии……     12 
3  Архитектура клиент-сервер……………………………………………    13 
4  Программирование для мобильных платформ………………………     17 
4.1  Общие сведения о мобильной разработке…………………….     17 
4.2  Архитектурный паттерн MVP……………………………........     21 
5  Состав программ и основные алгоритмы………………………….....    24 
5.1  Программа для моделирования ad-hoc сетей………………..     24 
5.1.1  Генерация узлов……………………………………………..     25 
5.1.2  Установка соединений между узлами сети……………….      26 
5.2  Распараллеливание вычислений ……………………….........       28 
5.3  Организация сервера……………………………………….....       29 
5.3.1  Алгоритм обработки запросов………………………........       30 
5.4  Структура проекта клиентского Android-приложения ……      32 
5.4.1 Логика работы клиентского приложения…………….      34 
6  Демонстрация работы мобильного клиента………………………..      35 
Заключение………………………………………………………………     42     
Список использованных источников………………………………….      43 
Приложение А Состав программ ………………………………………..   44 
ВВЕДЕНИЕ 
Компьютерные ad hoc сети – это беспроводные децентрализованные сети с n узлами, расположенными в некоторой ограниченной области S. Каждый узел характеризуется радиусом действия приемопередатчика сигналов r. Два узла могут обмениваться информацией, если расстояние между ними меньше r. 
В настоящее время интенсивно развивается научное направление в области построения телекоммуникационных систем с динамической топологией сети. Подобные системы получили название MANET (Mobile аd hoc Networks). Дальнейшая тенденция развития MANET – это их полная интеграция в другие системы связи общего или специального использования. 
Основное назначение подобных сетей – организация связи между подвижными объектами – людьми, автомобилями, железнодорожным и водным транспортом, военными объектами, помощь при бедствиях или в случае экстренных ситуаций и происшествий. 
Ad-hoc сети будут полезны в тех случаях, когда развертывание полноценной стационарной сети затруднено, дорого или невозможно. 
Преимущества беспроводных мобильных сетей над стационарными заключаются в надежности, быстроте развертывания, отказоустойчивости. Так как нет фиксированной топологии, Ad-hoc сети можно разворачивать где и когда угодно. 
Недостатки мобильных сетей тоже есть. Это такие факторы, как небольшой радиус действия из-за необходимости экономии заряда мобильных устройств, а также естественных и искусственных препятствий, имеющихся на территории развертывания. 
В случае комплексных сетевых систем развёртывание и анализ могут быть крайне сложными.  
Адекватное сравнение с чисто теоретических позиций затруднено тем, что на процесс передачи данных в Ad-hoc сетях оказывает влияние большое число различных факторов, многие из которых носят случайных характер и слабо поддаются строгому математическому анализу.  
Мобильные приложения – самый быстрый и удобный способ получения информации для пользователя, учитывая, что смартфоны и планшеты есть почти у каждого человека в мире. 
Клиент-серверный подход при разработке программного обеспечения в настоящее время получил широкое распространение и используется повсеместно. Используя такой способ, все вычисления, требующие вычислительных ресурсов, переносятся на высокопроизводительные сервера, экономя ресурсы мобильных устройств. От клиента требуется лишь активное Интернет-соединение. Задача выполняется на сервере, а на клиенте отображается лишь результат ее выполнения. Таким образом, задача упрощается и для пользователя, и для разработчика. 
Целью работы является построение клиент-серверной архитектуры для выполнения задач статистического моделирования – удаленного генерирования сетей и анализ их характеристик, таких как количество компонент связности сгенерированной сети, зависимость математических ожиданий от количества вершин в ней и построение графиков для проведения аналитических исследований. 
 
 
 
 
 
 
 
 
1  Моделирование беспроводных Ad-hoc сетей 
1.1 Общие сведения о генерации сетей 
В качестве математической модели Ad-hoc сети можно использовать неориентированный геометрический граф, где вершинами являются узлы сети, а ребрами – соединения между узлами. Так как топология сети заранее неизвестна, поэтому она будет случайной.  
То есть генерируется случайным граф с n вершинами в некоторой области.  
 
 
 
Рисунок 1 – Ad-hoc сеть 
 
      В дипломной работе будем считать, что сеть ограничена некоторой сферой с радиусом R, узлы сети также имеют вид сферы и радиус          действия, равный r. Между двумя узлами устанавливается соединение, если расстояние между ними меньше r.  
Распределение вероятностей координат узлов – трехмерное равномерное. Для случайного распределения узлов внутри общей сферы радиуса R используется 	сферическая 	система 	координат. 	Далее 	случайно сгенерированные сферические координаты узлов переводятся в декартовы координаты для удобства выполнения геометрических операций. 
 
Сферическими координатами называют систему координат для отображения геометрических свойств фигуры в трёх измерениях посредством задания трёх координат, где  r — кратчайшее расстояние до начала координат, а  и  — зенитный и азимутальный углы 
соответственно. 
Три координаты  (r,  , ),  определены как: 
 r ≥ 0 — расстояние от начала координат до заданной точки . 
 0 ≤ ≤ 180 º   — угол между осью  и отрезком, соединяющим       o начало координат и точку . 
 0 ≤  ≤ 360º    — угол между осью  и проекцией отрезка,    o соединяющего начало координат с точкой  на плоскость . 
         Важно заметить, что r < V, где V – радиус общей сферы. 
Если заданы сферические координаты точки, то переход к декартовым осуществляется по формулам (1): 

		   	 	 	 	 	 	 	 	 (1) 

 
Зенитный угол генерируется в пределах от 0 до 180°, азимутный  в пределах от 0 до 360°. Преобразование сферических координат в декартовы происходит автоматически при создании нового узла и получении им сферических координат.  
В программе используются следующие геометрические операции: 
1.  Нахождение расстояния от точки до точки в пространстве. 
2.  Нахождение модуля вектора. 
3.  Разность векторов. 
4.  Произведение векторов. 
5.  Нахождение расстояния от точки до прямой в пространстве. 
 
1.2 Общие сведения об анализируемых характеристиках 
Статистическое моделирование — исследование объектов познания на их статистических моделях; построение и изучение моделей реально существующих предметов, процессов или явлений с целью получения объяснений этих явлений, а также для предсказания явлений или показателей. В дипломной работе моделировать будем беспроводные мобильные Ad-hoc сети. Для моделирования будем генерировать сети при различные размерах общей сферы, размерах препятствия (случаи, когда препятствие занимает 0%, 10%, 20%, 50% от объема сферы) и при разных количествах генерируемых узлов сети. Для каждой новой полученной сети будем вычислять количество компонент связности, количество установленных соединений между узлами сети. Также необходимо определить зависимость математических ожиданий от количества вершин в графе. 
Сбор данных будет происходить следующим образом: в цикле генерируются случайные графы, вычисляются характеристики. По окончании генерации полученные характеристики анализируются, создается статистика на основе этих аналитических данных. Результат будет представляться в виде графиков. Для большей наглядности результата эксперимента на одном графике будут выводиться значения без препятствия и с препятствиями различных радиусов. 
 
Математическое ожидание – это среднее значение случайной величины. В нашем случае это будет среднее значение установленных соединений между узлами сети в зависимости от количества узлов. 
	   	 	 	 	 	 	 	 	 	(2) 
 
Компонента связности графа — некоторое множество вершин графа такое, что для любых двух вершин из этого множества существует путь из одной в другую, и не существует пути из вершины этого множества в вершину не из этого множества. В сетях Ad-hoc связность важна по той причине, что от нее зависит целостность сети, а следовательно и общая работоспособность и надежность. Чем меньше компонент связности, тем больше узлов связаны между собой. 
В программе для поиска компонент связности используется поиск в глубину. 
Дисперсия случайной величины - мера разброса данной случайной величины, то есть её отклонения от математического ожидания. 
Обозначается D[X]. 
Пусть Х — случайная величина, определённая на некотором вероятностном пространстве. Тогда дисперсией называется формула на рисунке 9, где символ М обозначает математическое ожидание. 
 
	   	                                                                              (3) 
 
 
 
 	 
2  Способы и технологии параллельного программирования 
2.1 Общие сведения о параллельном программировании 
Параллельное программирование – способ написания компьютерных программ, при котором программы разрабатываются как набор вычислительных процессов, взаимодействующих друг с другом и работающих одновременно, то есть параллельно. 
  Параллельные программы могут физически исполняться либо последовательно на единственном процессоре — перемежая по очереди шаги выполнения каждого вычислительного процесса, либо параллельно — выделяя каждому вычислительному процессу один или несколько процессоров (находящихся рядом или распределённых в компьютерную сеть). 
  Главная сложность при планировании архитектуры параллельных вычислений – обеспечение правильной и корректной последовательности взаимодействий между различными параллельными вычислительными процессами, а также распределение ресурсов между процессами и их обмен. 
Программа, выполняемая параллельно, примерно выглядит следующим образом: 
 
 
Рисунок 2 – структура параллельной программы. 
 
Как видно на рисунке – определенные области программы выполняются в несколько потоков. При завершении этапа вычислений, нити потоков соединяются, происходит синхронизация, далее вычисления разделяются снова. 
При написании параллельных программ требуется особое внимание работе с данными. При неправильной проектировании программы возникают следующие ошибки: 
* Гонка данных: 
Эта ошибка возникает в случае одновременной попытки изменения разыми процессами некоторой общей области данных. Конечное значение будет неправильным и будет зависеть от того, какой процесс взаимодействовал с ней последним. В случае, когда несколько задач попытаются обновить один и тот же ресурс данных, такое состояние «гонок» называют «гонкой»данных (data race).  Для решения этой проблемы следует ввести «критические секции», то есть области, в которых в момент времени должен работать только один процесс, а остальные должны находиться в ожидании в этот момент времени, пока взаимодействующий с областью данных процесс не закончит свою работу. После чего начать выполнять критическую секцию сможет другой поток. Такая схема работы называется "блокировкой" потоков. 
* Дедлок: 
Клинч, дедлок (deadlock) - разные названия одной из самых серьезных проблем, возникающих при параллельном программировании.  Такая ошибка может возникнуть в том случае, когда несколько потоков пытаются получить общие ресурсы в один момент времени. При клинче каждый из потоков успевает захватить один из общих ресурсов. Для окончания работы каждому потоку необходимы другие ресурсы, захваченные другими потоками. В результате, никто из потоков не может завершить свою работу, все стоят в очередях, которые не двигаются, - работа замирает – приложение "зависает". Это худшее, что может случиться с приложением. 
 
 
Способы синхронизации параллельного взаимодействия: 
 
* Взаимодействие через разделяемую память: на каждом процессоре мультипроцессорной системы запускается поток исполнения, который принадлежит одному процессу. Потоки обмениваются данными через общий для данного процесса участок памяти. Количество потоков соответствует количеству процессоров. 
 
* Взаимодействие c помощью передачи сообщений: на каждом процессоре многопроцессорной системы запускается однопоточный процесс, который обменивается данными с другими процессами, работающими на других процессорах, с помощью сообщений. Процессы создаются явно, путем вызова соответствующей функции операционной системы, а обмен сообщениями — с помощью библиотеки (например, реализация протокола MPI), или с помощью средств языка. 
 
* Гибридный способ: на многопроцессорных системах с распределённой памятью (DM-MIMD), где каждый узел системы представляет собой мультипроцессор с общей памятью (SM-MIMD), можно 
использовать гибридный метод программирования[4]. На каждом узле системы запускается многопоточный процесс, который распределяет потоки между процессорами данного узла. Обмен данными между потоками на узле осуществляется через общую память, а обмен данными между узлами — через передачу сообщений. В этом случае количество процессов определяется количеством узлов, а количество потоков — количеством процессоров на каждом узле. Гибридный способ программирования более сложен (требуется особым образом переписывать параллельную программу), но наиболее эффективен в использовании аппаратных ресурсов каждого узла многопроцессорной системы. 
Разумеется, в такой системе можно также использовать и исключительно метод передачи сообщений, то есть запустить на каждом процессоре каждого узла отдельный процесс. В этом случае количество процессов (и потоков) будет равно количеству процессоров на всех узлах. Этот способ проще (в параллельной программе надо только увеличить количество процессов), но является менее эффективным, так как процессоры одного и того же узла будут обмениваться друг с другом сообщениями, словно они находятся на разных машинах. 
 
2.2 Краткий обзор используемой параллельной технологии 
	OpenMP (Open 	Multi-Processing) — 	открытый 	стандарт 
для распараллеливания программ на языках Си, Си++. Это совокупность директив директив компилятора, библиотечных процедур и переменных окружения ,для программирования многопоточных приложений на многопроцессорных системах с общей памятью. OpenMP работает максимально абстрактно и не вовлекает программиста в сложные задачи, вроде разделения ресурсов и взаимодействия между процессами. Позволяет без особых усилий и затрат времени распараллелить уже существующую программу, путем добавления OMP-директив компилятора. Значительная часть функциональности OpenMP реализуется при помощи директив. Они должны быть явно вставлены программистом, что позволит выполнять программу в параллельном режиме. 
Объектом действия большинства директив является один оператор или блок, перед которым расположена директива в исходном тексте программы. 
 
 
3. Архитектура клиент-сервер 
Клиент-сервер – сетевая архитектура, в которой сетевое взаимодействие разделено между двумя сторонами – клиентом и сервером. Клинт выступает в роли заказчика, запрашивая данные у сервера, а сервер, в свою очередь, в роли поставщика, поставляю данные клиентам. Клиент и сервер –это компьютерные программы. Они взаимодействуют между собой через компьютерную сеть посредством сетевых протоколов и находятся на разных вычислительных устройствах, но могут также выполняться и на одном.  
Сервер – программа, принимающая запросы от клиентов и предоставляющая 
им данные в зависимости от полученного запроса.
 
 
Рисунок 3 – схема архитектуры клиент-сервер 
 
Преимущества: 
 
 Нет необходимости дублировать код в клиентских приложениях. 
 
 Требования к клиентским устройствам снижаются, так как все вычисления производятся на сервере. 
 
 
 Данные клиентов хранятся на сервере, который защищен лучше, чем большинство клиентов. Зачастую, на сервере организована система управления полномочиями, распределяющая уровни доступа к данным между клиентами с различными правами. 
Недостатки: 
 
 Отказ в работе сервера может сделать вывести из строя всю сеть. Неработоспособным сервером следует считать сервер, производительности которого не хватает на обслуживание всех клиентов, либо сервер, который выключен (вышел из строя). 
 
 Поддержка работы такой система требует специалиста – системного администратора. 
 
 Стоимость оборудования выше. 
Существует несколько видов архитектуры клиент-сервер, это такие виды как двухзвенная или трехзвенная. Двухзвенная архитектура используется в клиент-серверных системах, где сервер отвечает на клиентские запросы напрямую и в полном объеме, при этом используя только собственные ресурсы. Т.е. сервер не вызывает сторонние сетевые приложения и не обращается к сторонним ресурсам для выполнения какой-либо части запроса. 
Архитектура дипломной работы является двухзвенной.  
Зачастую, выполнение запроса занимает времени больше, чем время, затрачиваемое на пересылку запроса и результата. Поэтому в серверах применяются системы распределения транзакций между доменами сервера. Транзакция - это набор команд, которые либо выполняются все или не выполняется ни одна. Домен - это элемент сервера. Нередко сервер на физическом уровне представляет собой не один, а группу компьютеров, объединенных в одну систему для обеспечения каких-либо операций.  
Сервер способен принимать запросы от нескольких клиентов сразу и работать с ними. Это называется многопользовательским режимом, но на самом деле, сервер обрабатывает запросы последовательно. Если приходит несколько запросов в один момент, то они становятся в очередь. Иногда запросы могут иметь различный приоритет. Запросы с более высоким приоритетом должны выполняться раньше чем запросы с более низким приоритетом. 
	Операционная 	система 	Windows 	является 	многозадачной 	и 
многопоточной. Это означает, что в системе может одновременно быть запущено на исполнение несколько задач. Многопоточность позволяет запускать несколько задач, каждая из которых будет обрабатывать отдельный запрос, тем самым повышая производительность сервера. 
Существует концепции построения системы клиент-сервер: 
1)  Слабый клиент - мощный сервер. В такой концепции всеми вычислениями оперирует только сервер. После окончания вычислений он посылает готовый результат, не требующий дополнительной обработки. Клиент только ведет диалог с пользователем: составляет запрос, отсылает запрос, принимает запрос и выводит информацию на экран (на принтер, в файл). 
2)  Сильный клиент - часть обработки информации перепоручается клиенту, например предварительная обработка данных. 
При частичной обработке данных на клиенте "время ожидания" меньше. Меньше оно за счет упрощения запроса и времени его выполнения. 
Отсюда меньше ожидание в очереди для исполнения запроса. Безусловно, что время конечной обработки на клиенте может быть немного выше за счет разности в производительности сервера. 
 Отсюда может несколько возрастать время ожидания. В конечном счете, это все равно выгоднее, т.к. время ожидания в очереди запросов на сервере меньше. Многие серверы не выдерживают нагрузки ("напора" запросов) и просто "подвисают". В таком случае есть два альтернативных способа: увеличение производительности и перенос части операций над данными на клиента. Как правило, увеличение производительности значительно более дорогостоящая операция, и тоже, в своем смысле, конечная. Остается только "разгрузка" сервера и перенос части обработки данных на клиента. Нередко в ряде организаций в качестве сервера сознательно используют устаревшие компьютеры. На них хорошо размещать файловые хранилища, принт-серверы (к нему подключается офисный принтер), WEB-серверы (Интернет-серверы), небольшие базы данных (серверную часть). Это оправдано с экономической точки зрения. 
Применение самых мощных компьютеров в качестве серверов целесообразно в банковской сфере, т.к. объем платежей неизменно возрастает. Соответственно, возрастает необходимый объем вычислительных ресурсов. Здесь оправдана "борьба" за единицы процентов увеличения производительности. 
 
 
 
 
 
 
 
 
 
 
4  Программирование для мобильных платформ 
4.1 Общие сведения о мобильной разработке  
Разработка приложений для мобильных платформ является одним из ведущих направлений в мире IT в настоящее время.  Android – мобильная операционная система, основана на ядре Linux и собственной реализации виртуальной машины Java от Google. Но несмотря на то, что платформа основана на ядре Linux, она имеет много уязвимостей. Платформа развивается со стремительной скоростью и по возможностям не уступает даже ПК, В настоящее время разработка под эту мобильную ОС является одной из основных тенденций в мире разработки вообще. ОС предоставляет пользователям возможность работы с сетью интернет, службами геолокации, Wi-Fi, Bluetooth и протоколы передачи данных через сотовую сеть (GPRS, EDGE, 3G и др.). 
Android содержит встраиваемый браузер на базе WebKit - того же механизма с открытым исходным кодом, который лежит в основе браузера Safari для iOS. 
Приложения, написанные для Android, состоят из следующих элементов: 
* Активити(Activity) – это экраны, которые видит пользователь, при работе с приложениями.  
* Фрагменты (Fragment) - это модули, содержащие графический интерфейс, которые встраиваются в активити. За счет использования фрагментов, приложения проще разрабатывать, т.к фрагмент имеет собственную логику и может быть переиспользован. Зачастую, активити может содержать несколько фрагментов. 
* Сервисы (Services) - сервисы отвечают за работу функций приложения в фоне. Они могут продолжать работать, даже когда пользователь не взаимодействует с приложением. 
* Сервисы применяются при длительных операциях взаимодействия с сетью, мониторинга ресурсов или для фоновой проверки обновлений. 
* Источники данных (Content providers) - источник данных можно представить себе как сервер баз данных. Его задача - управление доступом к хранящимся данным, таким как база данных SQLite. Если приложение совсем простое, источник данных создавать не обязательно. Если вы пишете более сложное приложение или приложение, в котором к данным обращается несколько действий или приложений, источник данных служит средством организации доступа к вашей информации. 
* Приемники (Broadcast receivers) - Android-приложение может запускаться для обработки элемента данных или реагирования на события, например, на получение текстового сообщения. 
 
Приложение для Android обязательно должно иметь файл AndroidManifest.xml, в котором содержится основная информация о приложении и его конфигурации для правильной установки приложения на устройстве пользователя. В манифесте описывается такая информация, как: необходимые имена классов и типы событий, которые может обрабатывать приложение, разрешения, требуемые для его работы. Так, если приложению нужен доступ к сети – например, чтобы загрузить файл, - соответствующее разрешение должно быть явно указано в файле манифеста. Такая защита путем декларирования помогает уменьшить вероятность повреждения устройства по вине некорректно написанного приложения. Стоит отметить, что система разрешений изменилась с выходом Android 6.0 и разрешения, 
запрашиваемые 	приложением 	не 	отображаются 	при 	установке, 	а запрашиваются в режиме реального времени. Т.е. приложение должно иметь минимум разрешений, необходимых для работы, т.к. пользователь вправе отказать приложению на запросы некоторых разрешений, например если он не хочет давать доступ камере к своему местоположению. 
Для разработки под Android необходима IDE и Android SDK, знание языка программирования Java и языка XML для создания макетов интерфейсов. Неотъемлемой частью разработки является запуск приложений, поэтому также необходимо реальное устройство, либо эмулятор. Особо популярны два эмулятора: Genymotion, Android Studio Emulator 2.0. 
* Genymotion – это быстрый эмулятор Android, который включает в себя настроенные образы Android (x86-с аппаратным ускорением OpenGL), идеальный для тестирования приложения. К минусам этого эмулятора можно отнести нестабильность: эмулятор запускается далеко не с первого раза, а в некоторых случаях количество неудавшихся попыток запуска достигает 10! 
 
* Android Studio Emulator 2.0 – это относительно новый сверхбыстрый эмулятор, выпущенный компанией Google и поставляемый вместе со средой программирования Android Studio 2.0. 
Разработчики уверяют, что по сравнению со старым эмулятором, новый работает до 10 раз быстрее и также приложения устанавливаются на него до 3 раз быстрее. 
К минусам этого эмулятора можно отнести требовательность к ресурсам: для комфортной разработки в Android Studio и отладки на этом эмуляторе нужно не менее 8гб оперативной памяти и процессора не менее чем с 4 ядрами. 
 
При работе над дипломным проектом используются все три варианта тестирования: два эмулятора и реально устройство (Google Nexus 5). 
 
  Разработчик приложений должен хорошо знать особенности ОС Android и помнить о сегментации устройств и различных версий ОС. Существуют некоторые трудности, которые нужно учитывать при разработке: 
1)  Приложение требует для установки в два раза (или даже в четыре) больше места чем оригинальный размер приложения. 
2)  Скорость работы с файлами на встроенной флэшке падает в десятки раз при уменьшении свободного места. 
3)  Каждый процесс может использовать до 16 Мб (иногда 24 Мб) оперативной памяти. 
4)  Зачастую один и тот же код или элемент интерфейса ведет себя поразному на разных устройствах и версиях Android. Несмотря на разработку библиотеки поддержки Support Library, этот пробел не удается устранить полностью. 
5)  Всегда найдется специфическое устройство, на котором приложение работает совершенно не так, как задумано. Из этого вытекает пункт 6. 
6)  Сложность отладки. Как правило, средний разработчик не может протестировать приложение на всех доступных устройствах по причине их многообразия и собственно, отсутствия в наличии их у разработчика. 
 
Существует два способа разработки для мобильных устройств: 
написание нативных приложений и использование кроссплатформенного движка. 
Нативным способ – написание приложений на родной языке программирования для платформы. Для Android это Java и Android SDK. 
Такой способ наиболее гибкий и удобный, и производительный. Но недостаток его в том, что целевая платформа только одна. Нативный способ разработки стоит выбирать в том случае, если перенос приложения на другие платформы не планируется. 
Кроссплатформенный способ – при выборе этого способа, приложения разрабатываются сразу для нескольких платформ (Android, iOS, WP). Такие приложения имеют набор общей логики, общий интерфейс, но мелкие детали приходится дорабатывать в зависимости от платформы. Кроссплатформенная разработка более подвержена ошибкам, чем нативный способ. Также, количество документации к кроссплатформенным средствам существенно ниже, чем к нативным. К крассплатформенным средствам разработки можно отнести такие как Xamarin от Microsoft, Apache Cordova, Phonegap, также 
Microsoft сделала недавно возможной кроссплатформенную разработку в IDE Visual Studio. 
 
4.2 Архитектурный паттерн MVP 
Архитектурные шаблоны являются важнейшей частью ПО. Они помогают сохранить код в чистоте, сделать его расширяемым и тестируемым. Шаблон MVP позволяет отделить уровень представления от уровня логики, для того что бы поведение приложения не зависело от его конкретного внешнего вида.  Android не определяет зоны ответственности между компонентами приложения, поэтому вся логика работы с UI и данными приложения описана внутри одной Activity, что не позволяет сделать приложение расширяемым и легко тестируемым. Использование MVP позволяет решить эту проблему. Есть много разных подходов для реализации MVP, но не зависимо от выбранного решения должны сохранятся три компонента: 
1.  Presenter выступает в качестве посредника между View и Model. Он извлекает данные из модели и передает их во View. Но в отличие от типичного MVC, он также решает, что нужно делать, когда вы взаимодействуете с View. 
Презентер отвечает за: 
* Загрузку моделей; 
* Сохранение ссылки на модель и состояния представления; 
* Форматирование того, что должно быть отображено на экране, и указание представлению отобразить это; 
* Определение необходимых действий, когда получены входные события от представления. 
2.  View, как правило, реализуется в Activity и Fragment, которые содержат ссылку на презентер. Единственное, что делает View, это вызывает методы презентера при каком-либо действии пользователя. 
Представление отвечает за: 
* Создание 	экземпляра 	презентера 	и 	механизм 	его присоединения/отсоединения; 
* Оповещение презентера о важных для него событиях жизненного цикла; 
* Сообщение презентеру о входных событиях; 
* Размещение представлений и соединение их с данными; 
* Анимации; 
* Отслеживание событий; 
* Переход на другие экраны 
3.  Model рассматривается в качестве поставщика данных, которые будут отображаться во View. Модель — это набор бизнес-логики. 
 
 

 
Рисунок 4 – взаимодействие компонентов приложения в MVP 
 
Также использование паттерна MVP почти полностью решает вопрос с сохранение состояния активити при ее пересоздании. В традиционном подходе все данные хранятся в активити, а при пересоздании активити она разрушается и данные теряются. В паттерне MVP активити не хранит никаких данных. При создании активити в первый раз создается презентер для нее. Когда представление доступно для взаимодействие, презентер прикрепляется к активити, когда недоступно – открепляется. Тем самым избавляя приложения от главных проблем – утечек памяти, сохранения данных и привязки асинхронных операций к активити. Как известно, в ОС Android асинхронная задача AsyncTask имеет неявную ссылку на активити, ее запустившую и при после пересоздания активити AsyncTask хранит ссылку на несуществующую активити и в итоге результат асинхронной операции придет в никуда и случится утечка памяти.  С приходом MVP эта проблема также решена. Можно запускать асинхронные операции в модели. 
5  Состав программ и основные алгоритмы 
Для реализация программы, выполняемой на стороне сервера будет использоваться язык C++ и среда разработки Microsoft Visual Studio 2013, параллельная технология OpenMP. Для построения мобильного клиентского приложения на Android используется Android SDK, среда разработки Android Studio 2.1, библиотека Okio OkHttp для выполнения http запросов, библиотека GraphView для отрисовки графиков.  Для реализации сервера был выбрал скриптовый язык PHP 5.5, база данных MySQL. 
 
5.1  Программа для моделирования ad-hoc сетей 
Состоит из 4 классов:
1.  World – класс общей сферы, содержит в себе список узлов, препятствие, операции для работы с сетью (графом). Операция для генерации узлов, генерация препятствия, некоторые геометрические операции, такие как разность векторов, умножение векторов, модуль вектора, 
2.  Нахождение расстояние между двумя точками, расстояние от точки до прямой в пространстве, функция для проверки возможности установления соединения между двумя узлами. Также есть функции для подсчета компонент связности сгенерированной сети.  
3.  Elem – базовый класс узла в общей сфере. Содержит декартовы координаты, радиус узла. При создании объекта класса Elem, в конструктор передаются сгенерированные случайным образом зенитный и азимутный углы, кратчайшее расстояние от начала координат то узла. Далее, на основе этих величин осуществляется преобразование в декартовы координаты. Сферические координаты в классе не хранятся, только декартовы. 
4.  Node, Obstacle – классы, производные от Elem. Класс Node содержит список ребер и операцию для проверки наличия узла в списке ребер. 
 
5.1.1  Генерация узлов  
Класс World содержит операции для генерация узлов. 
Рассмотрим два случая: 
1. Общая сфера не содержит препятствий. Тогда алгоритм генерации узлов будет следующий: 
1.1.  Генерируем три случайные сферические координаты. 
1.2.  Создаем новый узел и добавляем его в список узлов графа. 
2. Общая сфера содержит препятствие. 
Алгоритм: 
2.1.  Генерируем три сферические координаты. 
2.2.  Создаем временный узел и задаем ему эти координаты. 
2.3.  Если препятствие и узел не пересекаются, добавляем узел в граф. 
Генерация происходит до тех пор, пока количество сгенерированных узлов меньше заданного кол-ва элементов для генерации. 
 Два элемента пересекаются, если расстояние между ними меньше радиуса самого элемента. Последовательность шагов: 
1. Вычисляется расстояние между двумя точками по форму 

                                   (3) 
  Если вычисленное расстояние меньше радиуса элемента, то возвращается значение true. Это означает что элементы пересекаются, иначе false. 
Алгоритм генерации препятствия следующий: 
1.1.  Генерируем три случайные сферические координаты. 
1.2.  Создаем новое препятствие и добавляем его в список препятствий графа. 
 
5.1.2  Установка соединений между узлами сети 
Одной из главных целей работы является поиск и установка соединения между узлами. Соединение устанавливается, если расстояние между двумя узлами меньше радиуса узла r. Наличие соединения означает возможность обмена информацией между этими узлами. Все множество соединенных узлов будет образовывать граф.  
Таким образом, необходимо проверить все пары вершин графа на возможное наличие связи между ними. 
Задача поиска разделяется на 2 случая: 
1.  Граф имеет препятствие в виде сферы. 
2.  Препятствие отсутствует. 
В первом случае узлы графа уже сгенерированы так, чтобы их координаты лежали за пределами радиуса препятствия. Препятствие может занимать 0%, 10%, 20% и 50% это объема общей сферы. 
Также для первого случая необходимо иметь процедуру для вычисления расстояние от точки (центра препятствия) до прямой (вектора между двумя узлами). 
Величина векторного произведения двух 3-мерных векторов равна площади параллелограмма, построенного на них. Однако эта площадь также равна произведению основания на высоту параллелограмма, а длина высоты - искомая 	дистанция 	d 	(P, 	L). 	Пусть  
 и 	. 
Представим, что точка  и точка  – центры узлов. Точка P – центр препятствия. Нахождение расстояние между точкой и прямой по формуле 
(4): 
 
		                                                                              (4) 
 
 
 
 
Рисунок 5 - Параллелограмм 
 
Сам алгоритм установления соединений между узлами сети заключается в следующем:  
1.  Перебираются все пары вершин графа. 
2.  Если расстояние между двумя узлами (node1 и node2), рассматриваемыми на текущей итерации, меньше r, то выполняется переход к следующему шагу алгоритма. 
3.  Если между узлами node1 и node2 еще нет соединения, то есть в списке ребер node1 нет пути к узлу node2, то переходим к следующему шагу. 
Дальнейшие действия алгоритма зависят от того, есть ли в графе препятствие. 
4.  Если препятствие есть, то необходимо проверить, мешает ли оно установлению соединения между узлами. Если да, выполнение алгоритма продолжается с другой парой узлов. Если нет, то устанавливается соединение между узлами, рассматриваемыми в данный момент. 
Если же препятствия нет и предыдущие пункты алгоритма истинны, то соединение устанавливается. 
В список ребер node1 добавляется узел node2 и, соответственно, в список node2 добавляется узел node1. 
 
5.2 Распараллеливание вычислений 
Основные вычисления в программе – генерация новых графов и обработка их статистических данных. Эти вычисления будем распараллеливать с помощью технологии OpenMp. Целью использования параллельных технологий является уменьшение времени, затрачиваемого на работу программы.  const int size = 100; const float node_radius = 1; const float obst_radius = 5; const float world_radius = 50; const int nodes_count = 200; 
 
int main() 
{#pragma omp parallel for reduction (+:comps) reduction(+:nodes) firstprivate(world)   for (int iters = 0; iters < size; ++iters) 
	 	{ 
 	 	world.generateObstacle();  	 	world.generateNodes(nodes_count);  	 	world.checkEdges(); 
 	 	disper[iters] = world.intersectionsCount();  	 	nodes += world.intersectionsCount();  	 	comps += world.componentsCount();  	 	world.clearWorld(); 
	 	} 
Здесь #pragma omp parallel for – директива компилятору, обозначающая начало параллельной секции для цикла for. 
 
reduction (+:comps) reduction(+:nodes)  - обозначают переменные, с которыми в цикле производятся reduction-операции (суммирование). При выходе из цикла, данные операции производится над копиями переменных во всех нитях, и результат присваивается оригинальным переменным. 
firstprivate(world) - приватные копии переменной при входе в параллельную область инициализируются значением оригинальной переменной. 
 
5.3 Организация сервера 
 В дипломной работе сервер, по сути, является посредником между вычислительной программой и клиентом, а также оберткой над базой данных. 
Серверный скрипт состоит из 4 классов: 
1.  Request – класс, описывающий набор параметров входящего клиентского запроса. Список параметров: 
$iterationsCount – количество итерация тестирования 
$nodeRadius – радиус узла Ad-hoc сети 
$obstacleRadius – радиус препятствия в Ad-hoc сети 
$worldRadius – радиус сферы, в которой проводится моделирование 
$nodesCount – количество узлов сети 
$hasObstacle – флаг, показывающий, есть ли препятствие в сфере 
Также класс содержит некоторые вспомогательные методы, такие как геттеры, сеттеры, конструктор и метод, преобразующий набор параметров в аргументы командной строки. 
2.  Response – класс, описывающий набор параметров результата 
$nodesAvg – математическое ожидание количества ребер в сети 
$dispersion – дисперсия математического ожидания количества ребер в сети 
$compsAvg – математическое ожидание количества компонент связности в сгенерированной сети. 
Также класс содержит некоторые вспомогательные методы, такие как геттеры, сеттеры, конструктор и метод, формирующий Json-объект из набора параметров. 
3.  DbOperations – класс-обертка над базой данных, содержащий все основные операции. 
Методы: findResult($connection, $request) – метод ищет в БД запись, соответствующую параметру $request. $request – перемнная типа Request. 
Возвращает Id эксперимента, если такой существует и -1, если нет. insertExperiment($connection, $params, $results) – метод, вставляющий две новые записи в две таблицы базы данных – параметры эскперимента и его результат. 
insertResult($connection, $result) – метод добавляет результат эксперимента в таблицу БД и возвращает ID вставленной записи. 
4.  Server – php файл, реализующий обработку входящих запросов и выдачу    результатов. 
 
5.3.1 Алгоритм обработки запросов  
  Сервер принимает GET запросы с параметрами запроса, в котором содержится набор параметров. Сервер проверяет, является ли запрос корректным, т.е все ли требуемые для проведения эксперимента параметры содержатся в параметрах запроса. Далее сервер проверяет, существует ли кэшированный эксперимент в базе данных: если да, то формируется JSONтело ответа и отправляется обратно клиенту, если нет, запускается исполняемый файл с аргументами командной строки, состоящими из параметров, полученных вместе с запросом. После завершения работы исполняемого файла, результат кэшируется в базу данных, а результат эксперимента отправляется клиенту.  
 
Формат Json-ответа: 
 
  
Рисунок 6 – формат Json ответа сервера 
 
Схема базы данных: 
 
 
Рисунок 7 – схема базы данных 
 
На сервере и клиенте всего по одной таблице. Таблица Params и таблица 
Result. 
 
 
 
5.4 Структура проекта клиентского Android-приложения 
В качестве архитектурного паттерна клиентского приложения используется паттерн MVP (model, view, presenter). 
 
Структура проекта в Android Studio: 
 
 
Рисунок 8 – структура проекта в Android Studio 
 
 
Основой бизнес-логики приложения являются классы работы с базой данных(DatabaseInteractorImpl), общения с сервером(ServerInteractorImpl). 
Пакет Activities: 
ChartActivity – активити(представление), в которой отображаются графики. MainActivity – стартовый экран приложения(представление), в котором отображен список параметров для проведения экспериментов. 
 
Пакет Data: 
Params – класс-обертка над параметрами эксперимента. 
Result – класс-обертка над результатом эксперимента. 
 
Пакет Presenters: 
ChartPresenterImpl – презентер для ChartActivity, отвечающий за преобразование данных для отображения в представлении, получаемых из базы данных. 
MainPresenterImpl – презентер для MainAcitivty. 
 
Пакет Utils: 
 Содержит вспомогательные классы с некоторым набором полезных функций. 
OkHttpHelper – вспомогательный класс, содержит HTTP клиент для выполнения сетевых операций. Класс отвечает за формирование параметров запросов.                                                                                          
DatabaseHelper – класс, отвечающий за создание базы данных для кэширования экспериментов. Содержит поля таблиц базы данных. 
 
 
5.4.1 Логика работы клиентского приложения 
На главном экране есть список параметров для проведения эксперимента. После того как пользователь вводит параметры и нажимает кнопку отправки, клиент проверяет, существует ли в локальном кэше результат эксперимента для введенных параметров эксперимента, если да, то пользователю сразу же выводится сообщение с результатами эксперимента. Если же нет, то устанавливает соединение с сервером и отправляется HTTP POST запрос на сервер со списком параметров. При получении ответа от сервера, клиент кэширует в локальную базу данных результат эксперимента, с соответствующим ему списком параметров, и так же выводит сообщение пользователю с результатом эксперимента. 
При наличии достаточного количества проведенных экспериментов, пользователь может нарисовать графики с зависимостями результатов эксперимента от различных входных параметров (количество узлов, радиус, радиус сферы и т.д). Всего существует три графика: 
График математического ожидания количества соединений в сгенерированной сети, график дисперсии математического ожидания в сгенерированной сети и график математического ожидания количества компонент связности в сгенерированной сети. 
 
 
 
 
 
 
 
6 Демонстрация работы мобильного клиента 
После запуска клиент встречает пользователя стартовым экраном со списком всех доступных параметров для моделирования Ad-hoc сетей, выполненным по гайдлайнам Material Design: 
 
 
 
 
Рисунок 9 – стартовый экран клиентского приложения 
 
 
Как видно, на экране перечислен список всех доступных параметров Ad-hoc сетей для проведения эксперимента. Внизу кнопка отправки запроса на сервер. 
 
После ответа сервера можно увидеть результаты: 
 
 
 
 
Рисунок 10 – результаты эксперимента в клиентском приложении 
 
 
Перейдем к экрану с графиками: здесь можно отобразить графики соответствующие набору параметров Ad-hoc сетей: 
 
 
 
Рисунок 11 – параметры для рисования графиков на клиентском приложении 
 
 
Можно запросить графики для каждой характеристики из эксперимента, либо отобразить для какой-либо одной. Также можно добавлять графики к сравнению с уже нарисованными, а можно очистить все и отобразить только один необходимый. 
Для удобства просмотра внизу экрана расположены кнопки изменения масштаба. Также, между экранами поддерживается навигация свайпом, либо кликом по табам вверху страницы. 
 
 
 
 
 
 
 
Рисунок 12 – график количества соединений между узлами 
 
Для того, чтобы не запоминать, какие эксперименты пользователь проводил, а какие нет, для удобства использования можно посмотреть историю из списка параметров экспериментов вместе с результатами. Каждый элемент списка может быть развернут по клику: 
 
 
 
 
Рисунок 13 – история экспериментов, проведенных на клиенте 
 
Проведем несколько экспериментов: для некоторых параметров получим результаты моделирования сначала без препятствия, затем с препятствием. Интервал количества узлов – от 100 до 1000. Количество итераций тестирования = 1000. Радиус узлов – 2, радиус препятствия – 2. 
 
 
 
 
 
 
 
 
 
 
 
   
На первом графике в легенде обозначены две кривые – зеленая (сеть с препятствием) и коричневая (сеть без препятствия). По скриншоту можно судить, что в сети с препятствием соединений несколько меньше. 
 
 
 
 
Рисунок 14 – сравнение графиков количества соединений для Ad-hoc сети с препятствием и без 
 
На втором графике на легенде обозначены две кривые – голубая (сеть без препятствия) и коричневая (с препятствием). По графику видно, что в сети с препятствием количество компонент связности немного увеличивается по сравнения с сетью без препятствия, что вполне логично. 
 
 
 
