Evaluation Warning: The document was created with Spire.Doc for Python.
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ 
Федеральное государственное бюджетное образовательное учреждение высшего образования 
«КУБАНСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ» (ФГБОУ ВО «КубГУ») 
 
Кафедра вычислительных технологий 
 
 
 	ДОПУСТИТЬ К ЗАЩИТЕ В ГЭК 
 	 
                                                                     Заведующий кафедрой                                                                      д. ф.-м. н., профессор 
_________________ Миков А.И. 
 	(подпись)           (инициалы, фамилия) 
__________________2016 г. 
 
 
 
ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА БАКАЛАВРА 
 
РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ ДЛЯ ВИРТУАЛЬНОЙ 
ЛАБОРАТОРИИ ИССЛЕДОВАНИЯ МОБИЛЬНЫХ AD HOC СЕТЕЙ 
 
 
Работу выполнил 	П. А. Беловол 
                                                                     (подпись, дата)                            (инициалы, фамилия) 
Факультет компьютерных технологий и прикладной математики Направление 02.03.02 – «Фундаментальные информатика и информационные технологии» 
Научный руководитель  
 к. ф.-м. н. ________________________________________________ О.Н Лапина 
                                                                     (подпись, дата)                            (инициалы, фамилия) 
Нормоконтролер __________________________________________ Ю.С Фисун 
                                                                     (подпись, дата)                            (инициалы, фамилия) 
 
 
 
 
 
Краснодар 2016  
 	 
РЕФЕРАТ 
Выпускная квалификационная работа 101 страниц, 32 рисунков, 11 источников, 2 приложения. 
AD HOC, БЕСПРОВОДНЫЕ СЕТИ, ГЕОМЕТРИЧЕСКИЙ ГРАФ, МОДЕЛИРОВАНИЕ 
Целью работы является разработка программных модулей для виртуальной лаборатории исследования мобильных ad hoc сетей. С помощью разработанных модулей можно выполнять построение моделей ad hoc сетей и производить анализ изменения их характеристик в зависимости от ряда параметров.  
Разработано клиент-серверное приложение, предназначенное для исследования моделей мобильных беспроводных сетей. В серверной части приложения используются разработанные программные модули. Клиентская часть приложения предоставляет удобный пользовательский интерфейс для коммуникации с сервером.  
Результат работы – программные модули, с помощью которых можно выполнять построение и исследование моделей ad hoc сетей, т.е. моделировать ad hoc сети, производить анализ параметров связности, анализ расположения компонент ad hoc сетей, выполнять построение графиков изменения характеристик сети от ряда параметров. В разработанном клиент-серверном приложении клиенты имеют доступ ко всем вышеперечисленным функциям. 
Таким образом, с помощью разработанных программных модулей можно создавать, обрабатывать и анализировать модели ad hoc сетей, концептуально представимых в виде геометрического графа.  
В работе использовался язык программирования С# в среде разработки Microsoft Visual Studio 2015. 
 
  	 
СОДЕРЖАНИЕ 
Введение ...................................................................................................................... 4 
1  Беспроводные сети ................................................................................................ 5 
1.1  Основные сведения и определения .............................................................. 5 
1.2  Представление сети с помощью геометрического графа .......................... 7 
2  Программные модули ......................................................................................... 10 
2.1  Основные определения ............................................................................... 10 
2.2  Модуль Graph .............................................................................................. 11 
2.3  Модуль Algorithms ...................................................................................... 12 
2.4  Модуль Test .................................................................................................. 16 
3  Клиент-сервер ...................................................................................................... 19 
3.1  Общие сведения ........................................................................................... 19 
3.2  Сервер TCP .................................................................................................. 22 
3.3  Клиент TCP .................................................................................................. 25 
3.4  Интерфейс клиента ..................................................................................... 27 
3.5  Интерфейс сервера ...................................................................................... 43 
Заключение ................................................................................................................ 45 
Список использованных источников ...................................................................... 46 
Приложение А Графики зависимости математических  
                           ожиданий величин.......................................................................... 47 
Приложение Б Исходный код программы .............................................................. 55 

ВВЕДЕНИЕ 
Целью дипломной работы является разработка программных модулей для построения и анализа моделей ad hoc сетей.  
 Разработанные программные модули должны реализовывать следующие задачи: моделировать ad hoc сети, производить анализ параметров связности, анализ расположения компонент ad hoc сетей, выполнять построение графиков изменения характеристик сети от ряда параметров. 
 Клиент-серверное приложение предоставит возможность клиентам удаленно выполнять операции для построения и исследования моделей мобильных беспроводных сетей. Решит задачу получения вычислений на маломощных ПК, где вычисления при объемном количестве итераций требуют значительных временных затрат. Все вычисления будут выполняться на серверной части с использованием разработанных модулей. Клиенты имеют удобный интерфейс для доступа к функциям сервера.  
Моделирование будет проводиться согласно имитационным методам, то есть необходимо строить модели, описывающие процессы так, как они проходили бы в действительности. Такой анализ поможет существенно сэкономить время развертывания данных сетей на физическом уровне, определить, в каком расположении сеть связна и имеет наилучшие характеристики.  
 	 
1 Беспроводные сети 
1.1 Основные сведения и определения 
Ad hoc - это одноранговые беспроводные сети передачи данных с переменной топологией и отсутствием четкой инфраструктуры, где каждый узел может выполнять функции маршрутизатора и принимать участие в ретрансляции пакетов данных. Подобные сети могут применяться во время военных действий, в структурах МЧС, в системах транспорта и различных силовых структурах. Пример структуры Ad hoc-сети изображен на рисунке 1.  
 

 
Рисунок 1 – Пример структуры ad hoc сети 
 
Специфика сетей ad hoc состоит в том, что их топология постоянно изменяется из-за перемещения узлов сети в пространстве или изменения условий распространения радиосигнала. Помимо этого, для ad hoc сетей, как и для любых беспроводных систем, характерны ограниченные полоса пропускания и зона радиовидимости. В результате протоколы и технические решения, используемые в классических проводных сетях передачи данных, например, централизованная маршрутизация с иерархией заранее назначенных маршрутизаторов, в сетях ad hoc оказываются неэффективными и не обеспечивают нужную производительность.  
Для успешного применения в ad hoc сетях протоколы маршрутизации должны обладать следующими качествами: 
* Быть распределенными. Все узлы в сети должны быть способны осуществлять маршрутизацию и не иметь жестко закрепленных за собой функций. 
* Обеспечивать надежную доставку пакетов в условиях постоянно изменяющейся топологии сети, когда использование классических механизмов гарантированной доставки, как, например, на транспортном уровне в протоколе ТСР, затруднено. 
* Обеспечивать малое время построения маршрута в условиях постоянно изменяющейся топологии сети. 
* Обладать механизмами оперативного обнаружения разрыва маршрута и его восстановления. 
* Не допускать образования петель в маршрутах. 
* Рассылать при функционировании как можно меньший объем служебной информации. 
* Обладать высокой масштабируемостью, т.е. обеспечивать высокую производительность сети при различных ее размерах. 
* Поддерживать QoS. 
Можно выделить следующие основные преимущества беспроводных сетей: 
* Низкая стоимость. Массовое производство электронных устройств значительно дешевле производства, установки и настройки многокомпонентного комплекса, решающего аналогичную задачу. 
* Быстрота развертывания. Беспроводная сеть готова к работе практически сразу же после размещения и включения всех устройств. 
* Высокая эффективность. Благодаря возможности одновременного применения большого количества устройств. 
 [Винокуров В.М., Пуговкин А.В. Маршрутизация в беспроводных 
мобильных Ad hoc сетях. с. 207] 	 
1.2 Представление сети с помощью геометрического графа 
Компьютерные ad hoc сети – это беспроводные децентрализованные сети с n узлами, расположенными в некоторой ограниченной области S. Каждый узел характеризуется радиусом действия приемопередатчика сигналов r. Два узла могут обмениваться информацией, если расстояние между ними меньше r. Математической моделью такой сети является так называемый геометрический граф. Работоспособность и качественные характеристики ad hoc сети могут быть описаны через такие характеристики геометрического графа как связность, количество компонент, длины маршрутов и прочее. 
Граф, или неориентированный граф G — это упорядоченная пара G = (V, E), где V — это непустое множество вершин или узлов, а E — множество пар (в случае неориентированного графа — неупорядоченных) вершин, называемых рёбрами. 
Представим компьютерную сеть соответствующим ей геометрическим графом  – набор GG = {V, K, r, S}, где V – множество вершин, K – отображение K: V  S, r – радиус действия приемо-передатчиков, S – ориентированная ограниченная поверхность, на которой располагаются вершины. 
Узлы сети – вершины графа в качестве атрибутов имеют координаты узла на заданной ограниченной поверхности S.Другим атрибутом является величина радиуса действия приемопередатчика, обеспечивающего прием сигналов от других узлов и передачу сигналов другим узлам. Таким образом, вершина находится в центре окружности некоторого радиуса. Если внутрь этой окружности попадает другая вершина, то связь между вершинами имеется. Такие вершины считаются смежными в геометрическом графе и соединяются ребром. 
[Миков А.И. Графы и грамматики. c. 68] 
 Пример такого геометрического графа приведен на рисунке 2. 
 
 
 	 
 
 
 
 
 
 

 
Рисунок 2 – Пример геометрического графа 
 
Поверхность (область) S определяется рельефом местности, на которой располагается компьютерная сеть. В общем случае она не является выпуклой и отображает также и препятствия распространению радиосигналов микроволнового и/или оптического диапазона. 
Геометрический граф GG = {V, K, r, S} порождает обыкновенный граф         G = {V, E} следующим образом: вершины обыкновенного графа соответствуют вершинам геометрического графа; вершины обыкновенного графа vi и v j смежны, т.е.(vi ,vj )E если длина отрезка между точками  P(vi ) и P(v j ) строго меньше величины r , и никакая часть этого отрезка не проходит «под» ориентированной поверхностью S (прямая видимость). 
На рисунке 3 изображен несвязный геометрический граф, состоящий из двух компонент связности. 
 
 
 
 
 
 

 
Рисунок 3 - Несвязный геометрический граф 
Граф можно представить в виде списочной структуры, состоящей из списков двух типов: списка вершин и списков ребер. Элемент списка вершин содержит поле данных и два указателя. Один указатель связывает данный элемент с элементом другой вершины. Другой указатель связывает элемент списка вершин со списком ребер, связанных с данной вершиной. Для ориентированного графа используют список дуг, исходящих из вершины. Элемент списка дуг состоит только из двух указателей. Первый указатель используется для того, чтобы показать в какую вершину дуга входит, а второй для связи элементов в списке дуг вершины. На рисунке 4 изображено списковое представление графа. [Свами М., Тхуласираман К. Графы, сети и алгоритмы. c. 125] 
 
 
graph
 
1
 
2
 
3
 
4
 
5
 
2
 
1
 
5
 
4
 
3
 

 
Рисунок 4 – Списковое представление графа 
 
Числами 1..5  на рисунке 4 помечены дескрипторы вершин, также пронумерованы вершины соответствующего графа, нарисованного справа от представления. На рисунке графа пары взаимно обратных дуг изображены линиями без стрелок. В представлении дугам графа соответствуют дескрипторы дуг и толстые стрелки – ссылки на дескрипторы вершин.  
 	 
2 Программные модули 
2.1 Основные определения 
Модуль — функционально законченный фрагмент программы. Во многих языках программирования оформляется в виде отдельного файла с исходным кодом или поименованной непрерывной её части. Некоторые языки поддерживают объединение модулей в пакеты. 
Принцип модульности является средством упрощения задачи проектирования ПС и распределения процесса разработки ПС между группами разработчиков. При разбиении ПС на модули для каждого модуля указывается реализуемая им функциональность, а также связи с другими модулями. Удобство использования модульной архитектуры заключается в возможности обновления (замены) модуля, без необходимости изменения остальной системы. 
Программный код часто разбивается на несколько файлов, каждый из которых компилируется отдельно от остальных. Такая модульность программного кода позволяет значительно уменьшить время перекомпиляции при изменениях, вносимых лишь в небольшое количество исходных файлов, и упрощает групповую разработку. Также это возможность замены отдельных компонентов (таких как jar, so или dll библиотеки) конечного программного 
продукта, без необходимости пересборки всего проекта (например, разработка плагинов к уже готовой программе). 
Роль модулей могут играть структуры данных, библиотеки функций, классы, сервисы и др. программные единицы, реализующие некоторую функциональность и предоставляющие интерфейс к ней. 
В данной работе программные модули определены как классы. Имеется несколько файлов: Graph.cs, Algorithms.cs, Test.cs. 
 	 
2.2 Модуль Graph 
Модуль Graph представляет целевую структуру ad hoc сети в виде геометрического графа, и содержит вспомогательные методы для построения и анализа.  
Методы, содержащиеся в модуле: 
* Добавление узла в граф. 
* Поиск узла в графе. 
* Проверка узлов на смежность 
* Получить узел по координатам x и y. 
* Поиск компонент связности 
* Сортировка компонент связности 
* Поиск главной компоненты связности 
* Количество узлов в главной компоненте связности 
* Количество ребер в главной компоненте связности 
* Расстояние ближайшей точки главной компоненты до границы области 
* Печать графа 
* Печать компонент связности 
* Равномерное распределение узлов в ограниченной области 
* Максимальная степень вершины главной компоненты 
* Количество компонент связности 
Graph содержит в себе вложенные классы Node – узел, Arc – ребро, данные классы имеют вспомогательный характер, содержат дополнительные поля и методы для доступа к этим полям. Для того чтобы использовать вышеперечисленные методы, содержащиеся в Graph необходимо создать новый экземпляр Graph, и через созданный экземпляр вызвать нужный метод.  
 
 	 
2.3 Модуль Algorithms 
Модуль  Algorithms содержит алгоритмы для построения и анализа 
выпуклой оболочки.  
Методы, содержащиеся в модуле: 
* Алгоритм для построения выпуклой оболочки QuickHull 
* Площадь выпуклой оболочки 
* Центр масс выпуклой оболочки 
* Количество углов выпуклой оболочки 
* Расстояние от центра тяжести многоугольника до центра области 
Algorithms содержит вложенный класс Shape – фигура, данный класс имеет вспомогательный характер для определения выпуклой оболочки.  
QuickHull  - рекурсивный алгоритм для построения выпуклой оболочки. 
Время работы: 
* Лучший случай, все точки внутри оболочки: O(n) 
* Худший случай, все точки на оболочке: O(n2) 
* Среднее время: O(nlogn) 
На первом шаге алгоритм выполняет создание четырехугольника, соединяющего крайние точки, как показано на рисунке 5. Только точки, лежащие вне его, могут лежать на оболочке и будут рассматриваться в дальнейшем. В Каждый лежащий вне четырехугольника участок будет рекурсивно обработан функцией Quickhull. На диаграмме ниже изображена обработка верхнего-правого угла. 
На шаге А также находится точка c - наиболее удаленная от линии (a,b). Следующим шагом определяем два множества точек: справа или на линии (a,c) и справа или на (c ,b), как показано на рисунке 6. Для них вновь выполняется вызов функции Quickhull. 
 	 

 
Рисунок 5 – 1 шаг алгоритма 	 	 	 	Рисунок 6 – 2 шаг алгоритма 
 
Ниже изображена аналогичная обработка первого множества. Находится точка c’, как показано на рисунке 7, наиболее удаленная от линии (a',b'), определяются два новых множества точек: справа или на (a',c') и (c',b'). 
Получается D на рисунке 8, которое затем обрабатывается дальше. 
 
 
Рисунок 7 – 3 шаг алгоритма 	 
 	 	Рисунок 8 – 4 шаг алгоритма 	 
Алгоритм продолжает выполнять вызов Quickhull для этих двух множеств. На рисунках 9 и 10 показан результат вызова для первого множества. Если множество состоит только из двух точек, рекурсия останавливается, возвращая эти две точки как сторону выпуклой оболочки (рисунок 10, сторону изображает черная линия). 

 
Рисунок 9 – 5 шаг алгоритма 	 	 	 	Рисунок 10 – 6 шаг алгоритма 
 
 Аналогичным способом обрабатываются верхний-левый, нижний-левый и нижний-правый углы, пока не получим полную выпуклую оболочку, как показано на рисунке 11. [Алгоритмы построения выпуклой оболочки. http://algolist.manual.ru/maths/geom/convhull/] 
 
 	 

 
Рисунок 11 – Полная выпуклая оболочка 
 
На случайном наборе точек этот алгоритм работает быстрее других алгоритмов. Наихудшее поведение алгоритм демонстрирует в случае, если заданные точки уже образуют выпуклый многоугольник, так как никакие точки в этом случае не отбрасываются. Тогда он выполняет O(n2) операций.  
 
 
 
 	 
2.4 Модуль Test 
Test – Модуль тестирования. Содержит методы, выполняющие вычисления для построения графиков зависимости. Использует вышеописанные модули Graph и Algorithms. 
Графики зависимостей, которые можно построить с помощью данного модуля: 
* Максимальная степень вершины главной компоненты от радиуса приема узла 
* Расстояние от центра тяжести многоугольника до центра области от радиуса приема узла 
* Количество углов в многоугольнике от радиуса приема узла 
* Количество компонент связности от радиуса приема узла 
* Количество узлов в главной компоненте от радиуса приема узла 
* Количество ребер в главной компоненте от радиуса приема узла 
* Расстояние ближайшей точки главной компоненты до границы области от радиуса приема узла 
* Площадь многоугольника от радиуса приема узла 
* Максимальная степень вершины главной компоненты от количества узлов в графе 
* Расстояние от центра тяжести многоугольника до центра области от количества узлов в графе 
* Количество углов в многоугольнике от количества узлов в графе 
* Количество компонент связности от количества узлов в графе 
* Количество узлов в главной компоненте от количества узлов в графе 
* Количество ребер в главной компоненте от количества узлов в графе 
* Расстояние ближайшей точки главной компоненты до границы области от количества узлов в графе 
* Площадь многоугольника от количества узлов в графе 
Графики формируются при определенном количестве итераций на каждую точку. Модуль содержит метод InitGraphTestMode, где одним из параметров целочисленного типа является countTestCycle – количество итераций. 
Для статистического анализа важный аспект – это количество тестов, которые необходимо выполнить, чтобы получить наиболее точные результирующие данные. На данном этапе формулируется задача об определении минимального количества итераций для более точных вычислений. Построены соответствующие графики - рисунок 12 и рисунок 13 при различном количестве итераций, а именно 4000, 2000, 200. 
 

 
	Рисунок 12 – График 1 	 	 	Рисунок 13 – График 2 
 
 	 
На рисунке 12 построен график зависимости площади многоугольника от радиуса приема узла, при итерациях: 4000 – соответствует прямой синего цвета, 2000 – соответствует прямой красного цвета, 200 – соответствует прямой зеленого цвета. Наибольшее отклонение можно заметить у линии зеленого цвета. Тем не менее у построенных прямых при итерациях 4000 и 2000 график функции выглядит практически одинаково и имеет относительно малую погрешность. Следовательно, можно заключить, что результаты, полученные при 4000 и 2000 итерациях практически эквиваленты. Из двух величин выбираем меньшее, так как, чем меньше выбранная величина, тем меньше потребуется времени для получения статистических результатов. 
К рисунку 13 также применимы вышеперечисленные рассуждения. 
 
 	 
3  Клиент-сервер 
3.1 Общие сведения 
Клиент-сервер — вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами. Физически клиент и сервер — это программное обеспечение. Обычно они взаимодействуют через компьютерную сеть посредством сетевых протоколов и находятся на разных вычислительных машинах, но могут выполняться также и на одной машине. Программы — сервера, ожидают от клиентских программ запросы и предоставляют им свои ресурсы в виде данных. Пример коммуникации клиент-серверного приложения изображен на рисунке 14. 
 
 

 
Рисунок 14 – Коммуникация сервера с клиентом 
 
Рассмотрим преимущества и недостатки использования клиент-серверной сетевой архитектуры. 
Преимущества: 
* Клиентам не нужно дублировать код серверной части программы 
* Низкие требования к программам клиентам, так как все основные вычисления выполняются на сервере 
* Все данные хранятся на сервере  	 
* Организация 	контроля 	полномочий, 	только 	клиенты 	с 
соотвествующими правами доступа могут осуществлять назначенные им соотвествующие операции Недостатки: 
* Неработоспособность сервера может сделать неработоспособной всю вычислительную сеть. Неработоспособным сервером следует считать сервер, производительности которого не хватает на обслуживание всех клиентов, а также сервер, находящийся на ремонте, профилактике и т. п 
* Поддержка работы данной системы требует отдельного специалиста 
 Высокая стоимость оборудования 
Платформа .NET Framework — это управляемая среда выполнения, предоставляющая широкий спектр служб для создания всех типов приложений. Она состоит из двух основных компонентов: общеязыковой выолняемой среды CLR и библиотеки классов .NET Framework. Рассмотрим службы, которые предоставляет .NET Framework выполняемым в ней приложениям: 
 
 Управление памятью. Во многих языках программисты должны предусматривать выделение и освобождение памяти, а также управлять временем жизни объектов. В приложениях .NET Framework  эти функции выполняет среда CLR 
 
 Общая система типов. В традиционных языках программирования базовые типы определяются компилятором, что усложняет взаимодействие между языками. В .NET Framework базовые типы определяются системой типов .NET Framework, при этом для всех языков  .NET Framework  используются одни и те же базовые типы  
 Обширная библиотека классов. Разработчикам не требуется писать код для выполнения стандартных низкоуровневых операций программирования, поскольку они могут использовать удобную библиотеку входящую в библиотеку классов .NET Framework 
 	 
 
 Платформы и технологии разработки. Платформа .NET Framework включает библиотеки для конкретных областей разработки приложений, например ASP.NET для веб-приложений, ADO.NET для доступа к данным и Windows Communication Foundation для приложений, ориентированных на службы 
 
 Взаимодействие языков. Языковые компиляторы, ориентированные на .NET Framework, выдают промежуточный код, называемый языком CIL (Common Intermediate Language), который в свою очередь компилируется во время выполнения средой CLR. С помощью этой функции подпрограммы, написанные на одном языке, доступны в других языках, поэтому разработчики могут создавать приложения на одном или нескольких предпочитаемых языках 
 
 Совместимость версий. Как правило приложения, разработанные на основе конкретной версии платформы .NET Framework, могут 
выполняться без доработок и на более поздних версиях платформы  
 Параллельное выполнение. Платформа .NET Framework помогает разрешать конфликты версий, поскольку на компьютере могут быть установлены несколько версий среды CLR. Это означает, что несколько версий приложений также могут существовать, и что приложение может выполняться на версии платформы .NET Framework, для которой оно было создано 
 
 Настройка для различных версий. Используя переносимую библиотеку классов платформы .NET Framework, разработчики могут создавать сборки, которые работают на нескольких платформах .NET Framework, например Windows 7, Windows 8, Windows 8.1, Windows 10, Windows 
Phone и Xbox 360 
[Абрамян М. Э. Visual C# на примерах. с. 256] 
Платформа Microsoft .NET Framework предоставляет многоуровневую, расширяемую и управляемую реализацию служб сети, которые можно быстро и легко интегрировать в приложения.    
Классы доступа к сети в  System.Net  и пространства имен System.Net.Sockets можно использовать для реализации клиент-серверных приложений. 
Класс Socket поддерживает 2 основных режима, синхронный и асинхронный. В синхронном режиме, вызовы функций, которые выполняют сетевые операции (например Send и Receive ) ожидают, пока операция не завершится до возвращения элемента управления в вызывающей программе. В асинхронном режиме, эти вызовы возвращают немедленно. 
Для приложений, которым необходимо выполнить простые запросы, класс WebClient предоставляет общие методы для передачи данных или загрузки данных с сервера через интернет. WebClient основан на классе WebRequest для обеспечения доступа к интернет-ресурсам. Поэтому класс WebClient может использовать любой зарегистрированный подключаемый протокол. 
 Для приложений, которые не могут использовать модель запроса - ответа или для приложений, которые должны прослушиваться в сети так же, как отправлять запросы, System.Net.Sockets - пространство имен предоставляет классы TCPClient, TCPListener и UDPClient. Эти классы отвечают за установление подключений с использованием различных транспортных протоколов и предоставляют сетевые подключения другим приложениям в виде потоков. [Троелсен Э. Язык программирования C# и платформа .NET с. 478] 
 
 
3.2 Сервер TCP 
TCP, или Transmission Control Protocol, используется как надежный протокол, обеспечивающий взаимодействие через взаимосвязанную сеть компьютеров. TCP проверяет, что данные доставляются по назначению и правильно. 
 	 
TCP — это ориентированный на соединения протокол, предназначенный для обеспечения надежной передачи данных между процессами, выполняемыми  или на одном и том же компьютере или на разных компьютерах. Термин “ориентированный на соединения" означает, что два процесса или приложения прежде чем обмениваться какими-либо данными должны установить TCPсоединение. В этом TCP отличается от протокола UDP, являющегося протоколом “без организации соединения”, позволяющим выполнять широковещательную передачу данных неопределенному числу клиентов. 
В данной работе в качестве протокола коммуникации между клиентом и сервером используется TCP, чтобы обеспечить упорядоченные, надежные двусторонние потоки байтов. Рассмотрим структуру работы сервера, изображенную на рисунке 15. 

 
Рисунок 15 – Функциональная диаграмма структуры сервера 
 	 
На первом шаге необходимо выполнить установление локальной конечной точки для сокета. Прежде чем открывать сокет для ожидания соединений, нужно подготовить для него адрес локальной конечной точки. Уникальный адрес для обслуживания TCP/IP определяется комбинацией IPадреса хоста с номером порта обслуживания, которая создает конечную точку для обслуживания. После того как адрес локальной конечной точки будет подготовлен, можно выполнять открытие сокета. Следующим шагом должно быть назначение сокета с помощью метода Bind().Для сокета открытого с помощью конструктора резервируется дескриптор, но не назначается имя. 
Чтобы сокет клиента мог идентифицировать потоковый сокет TCP, серверная программа должна назначить имя своему сокету. Метод Bind() связывает сокет с локальной конечной точкой. Вызов метода Bind() должен быть выполнен строго до любых вызовов методов Listen() и Accept(). 
После создания сокета и назначение ему имени, можно выполнять прослушивание входящих соединений используя метод Listen().В состоянии прослушивания сокет будет ожидать входящие попытки соединения. Метод Accept() извлекает из очереди ожидающих запросов первый запрос на соединение и создает для его обработки новый сокет. Новый сокет создан,но первоначальный сокет продолжает слушать и может использоваться с многопоточной обработкой для приема нескольких запросов на соединение от клиентов.Согласно клиент-серверной архитектуре, сокет выполняющий прослушивание соединений должен продолжать работу наряду с сокетами, созданными методом Accept(). 
Как только клиент и сервер установили между собой соединение, можно отправлять и получать сообщения, используя методы Send() и Receive() класса Socket. Метод Send() записывает исходящие данные сокету, с которым установлено соединение. Метод Receive() считывает входящие данные в потоковый сокет. При использовании системы, основанной на TCP, перед выполнением методов Send() и Receive() между сокетами должно быть установлено соединение.   
Точный протокол между двумя взаимодействующими сущностями должен быть определен заблаговременно, чтобы клиентское и серверное приложения не блокировали друг друга, не зная, кто должен отправить свои данные первым. 
Вызов метода Close() должен быть выполнен после того как обмен данными между сервером и клиентом будет завершен. [Кровчик Э. Net. Сетевое программирование для профессионалов с.176] 
 
 
3.3 Клиент TCP 
Приложение клиент имеет схожие функции, как и для приложения сервера.Так как используются те же самые методы для определения конечной точки, создания экземпляра сокета, отправки и получения данных и закрытия сокета: На рисунке 16 изображена функциональная диаграмма структуры клиента. 

 
Рисунок 16 - Функциональная диаграмма структуры клиента 
Метод Connect() – осуществляет установку связи с удаленным сервером.Если применяется протокол, ориентированный на установление соединения, такой как протокол TCP, метод Connect() синхронно устанавливает сетевое соединение между LocalEndPoint и указанной удаленной конечной точкой.Если используется протокол без установления соединения, метод Connect устанавливает удаленный узел по умолчанию.После вызова метода Connect можно послать данные на удаленное устройство с помощью метода Send() или получить данные с удаленного устройства, применив метод Receive(). 
Метод Connect() будет выполнять блокирование, если только не произведена установка для свойства Blocking значения false перед вызовом метода Connect(). Если используется протокол, ориентированный на 
установление соединения, такой как протокол TCP, и отключено блокирование, метод Connect() создаст исключение SocketException, так как требуется время на установление подключения.Для протоколов без установления соединения исключение не создается, так как они просто работают с удаленным узлом, заданным по умолчанию.Для получения определенного кода ошибки можно воспользоваться свойством SocketException.ErrorCode.Получив этот код, можно обратиться за подробным описанием ошибки к документации по кодам ошибок API Windows Socket версии 2 в библиотеке MSDN.Если ошибка возвращает значение WSAEWOULDBLOCK, подключение к удаленному узлу было инициировано объектом Socket, работающим в режиме с установлением соединения, но это подключение пока еще не завершено.Необходимо воспользоваться методом Poll(), чтобы определить, когда объект Socket завершает установление соединения. [Кровчик Э. Net. Сетевое программирование для профессионалов с.187] 
 	 
3.4 Интерфейс клиента 
Интерфейс клиента состоит из элементов управления, взаимодействуя с которыми, пользователь получает искомые вычисления. На рисунке 17 изображен главный интерфейс клиента. 
 

 
Рисунок 17 – Главный интерфейс клиента 
 
Прежде, чем начинать выполнение сетевых операций, необходимо установить соединение с целевым сервером. Для этого необходимо перейти в меню – соединение – параметры подключения и указать ip адрес и порт для связи с целевым сервером. Определить статус подключения можно с помощью статус строки, расположенной в нижней части окна приложения. 
Не подключен – соединение с сервером не установлено. 
Подключено к ip : port – соединение с сервером установлено, где ip и port, это соответственно ip адрес и порт сервера. 
Если сервер недоступен приложение выведет соответствующее сообщение. 
Валидация формы осуществляется на клиенте, в случае ввода некорректных данных пользователь получит соответствующее сообщение об ошибке, данные не будут отправлены на сервер. 
Рассмотрим функции для исследования ad hoc сетей. Одиночный эксперимент – пользователь указывает количество узлов, которое необходимо сгенерировать и радиус приема узла.  Вычисления, которые доступны: 
* Количество компонент связности. 
* Поиск главной компоненты. 
* Количество узлов в главной компоненте. 
* Количество ребер в главной компоненте. 
* Расстояние ближайшей точки главной компоненты до границы области. 
* Максимальная степень вершины главной компоненты 
 После выбора всех необходимых параметров для вычисления, пользователь нажимает на кнопку “Вычислить” – запрос отправляется к серверу, после обработки запроса сервером результаты вычислений будут отображены в консоли клиента. На рисунке 18 изображен детальный интерфейс одиночного эксперимента. 

 
Рисунок 18 – Интерфейс одиночного эксперимента 
Также можно наглядно представить, как расположены и связанны между собой узлы в ограниченной области. Кнопка “Рисовать” создает новое окно, содержимое которого будет сформировано из сгенерированного графа. На рисунке 19 изображено расположение узлов сгенерированного графа с параметрами n = 20 и r = 0,3. 
 

Рисунок 19 – Расположение узлов сгенерированного графа 
 Дескрипторы узлов, помеченные желтым цветом, являются узлами главной компоненты. Дескрипторы остальных узлов помечены красным. Если между узлами есть связь, то между ними ставится ребро, окрашенное в зеленый цвет. 
 	 
В качестве библиотеки для рисования используется ZedGraph. Данная библиотека обеспечивает высокую степень гибкости - почти каждый аспект графа может быть установлен пользователем и изменен.  
Пользователь может также построить выпуклую оболочку. К узлам, составляющим главную компоненту можно применить алгоритм QuickHull реализован в отдельном модуле в Algorithms.cs.Для этого необходимо в том же окне выполнить нажатие кнопки “Shape”. На рисунках 20,21,22 показана последовательность действий необходимая для построения фигуры. 
 

 
Рисунок 20  – Сгенерированный граф n=20, r=0.2 
 
После генерации заданного количества узлов n=20 с определенным радиусом приема каждого из них r=0,2, сформируются компоненты связности, главная компонента содержит наибольшее количество узлов. 
 	 
Входными данными QuickHull является набор точек (х,y) главной компоненты из которых и будет в дальнейшем построен  наименьший выпуклый многоугольник. Для этих узлов выполним алгоритм QuickHull для построения выпуклой оболочки. 
   

 
Рисунок 21 – Построенный выпуклый многоугольник 
 
 Построенная фигура содержит узлы с дескрипторами 18,16,7, 14.Данная выпуклая оболочка является четырехугольником, на рисунке 21 стороны фигуры окрашены в фиолетовый цвет. 
 Для отрисовки получившейся фигуры используется обьект Arrow библиотеки ZedGraph, у объекта имеется конструктор, который принимает обязательные параметры при инициализации в виде (x1,y1,x2,y2).Свойство Line.Width задает ширину линии отрисованной фигуры, Line.Color – задает цвет используемой линии.  	 
После всех операций инициализации нового обьекта Arrow необходимо добавить его в  GraphObjList с помощью метода Add. Все операции, связанные с перерисовкой, выполняются на клиенте. 
 

 
Рисунок 22 – Построенный выпуклый многоугольник 
 
На рисунке 22 практически в центре фигуры обозначена точка. С – центр тяжести многоугольника. Центром тяжести треугольника принято называть точку M пересечения его медиан. 
Рассмотрим интерфейс, с помощью которого клиент выполняет построение графиков зависимостей для исследования мобильных беспроводных сетей. В программе клиента - пользователь указывает количество точек, из вычисленных значений которых будет формироваться искомый график. Тип точек – радиус узла или количество узлов, соответственно N или R. Далее указывает количество итераций вычислений на одну точку.   
Доступные графики: 
* Максимальная степень вершины главной компоненты 
* Расстояние от центра тяжести многоугольника до центра области 
* Количество углов в многоугольнике 
* Количество компонент связности 
* Количество узлов в главной компоненте 
* Количество ребер в главной компоненте 
* Расстояние ближайшей точки главной компоненты до границы области  Площадь многоугольника 
На рисунке 23 изображен детальный интерфейс, с помощью которого можно выбрать какие именно графики необходимо построить. 
 

 	 
Рисунок 23 – Интерфейс для построения графиков 
 
Данные графики формируются с зависимостью от изменения параметра N или R, т.е. от количества узлов или радиуса приема узла соответственно. 
 	 
По нажатию кнопки “Построить” клиент, отправляет запрос серверу, сервер производит вычисления согласно запросу, сформированному клиентом. 
По окончанию вычислений сервер отправляет данные клиенту, клиент в свою очередь из полученных данных выполняет построение графиков. 
Для исследования математических ожиданий, примем во внимание, что случайная величина имеет дискретное равномерное распределение как на формуле (1).   
		    (1) 
Тогда её математическое ожидание (2): 
		  (2) 
равно среднему арифметическому всех принимаемых значений. Руководствуясь формулой (2) вычислим математические ожидания для следующих величин: 
* Максимальная степень вершины главной компоненты. 
* Расстояние от центра тяжести многоугольника до центра области. 
* Количество углов выпуклого многоугольника. 
* Количество компонент связности. 
* Количество узлов в главной компоненте. 
* Количество ребер в главной компоненте. 
* Расстояние от границы многоугольника до границы области. 
* Площадь выпуклого многоугольника. 
Затем смоделируем графики зависимостей, изображающие характеристики сети при указанных параметрах. 
 
 	 
Как уже рассматривалось в пункте 2.4, достаточно 2000 итераций для вычисления каждой точки графика с минимальной погрешностью. Таким образом все вышеперечисленные графики будут построены с количеством экспериментов равным 2000 на каждую точку. На рисунке 24 изображен график зависимости максимальной степени вершины главной компоненты от количества узлов в графе при R = 0,25 каждого узла. 
 

Рисунок 24  –  График зависимости максимальной степени вершины главной 
	компоненты от количества узлов в графе 	 
На рисунке 25 изображен график зависимости расстояния от центра тяжести многоугольника до центра области от количества узлов в графе при R =0,25. 
 
 
Рисунок 25  –  График зависимости расстояния от центра тяжести многоугольника до центра области от количества узлов в графе На рисунке 26 изображен график зависимости количества углов в многоугольнике от количества узлов в графе, при R =0,25. 
 
 

 
Рисунок 26  –  График  зависимости количества углов в многоугольнике от количества узлов в графе 
 	 
На рисунке 27 изображен график зависимости количества компонент связности от количества узлов в графе, при R =0,25. 
 
 

Рисунок 27  –  График  зависимости количества компонент связности от количества узлов в графе 
На рисунке 28 изображен график зависимости количества узлов в главной компоненте от радиуса приема узла, при N = 40. 
 

Рисунок 28  –  График  зависимости количества узлов в главной компоненте от радиуса приема узла 
На рисунке 29 изображен график зависимости количества ребер в главной компоненте от радиуса приема узла, при N = 40. 
 
 

Рисунок 29  –  График зависимости количества ребер в главной компоненте от радиуса приема узла 
На рисунке 30 изображен график зависимости расстояния ближайшей точки главной компоненты до границы области от радиуса приема узла, при N =40. 
 

Рисунок 30  –  График зависимости расстояния ближайшей точки главной компоненты до границы области от радиуса приема узла 
На рисунке 31 изображен график зависимости площади многоугольника от количества узлов в графе, при R = 0,25. 
 
 

 
Рисунок 31 – График зависимости площади многоугольника от количества узлов в графе 
 	 
3.5 Интерфейс сервера 
Интерфейс сервера представляет собой консольное приложение. В консоли отображаются строки вида: “ip адрес – метод”, т.е. можно посмотреть какие методы вызывал определенный пользователь. На рисунке 32 изображено консольное приложение – сервер. 

Рисунок 32 – Консольное приложение – сервер 
 
 Рассмотрим подробно строки, изображенные в окне консольного приложения на рисунке 32. 
* 127.0.0.1:59333 - TestMode(4000, 20, 0,2, n) 
* 127.0.0.1:59333 - TestMode(4000, 30, 0,2, n) 
* 127.0.0.1:59333 - TestMode(4000, 40, 0,2, n) 
* 127.0.0.1:59333 - TestMode(4000, 50, 0,2, n) 
* 127.0.0.1:59333 - TestMode(4000, 60, 0,2, n) 
TestMode (4000, 60, 0,2, n) – метод с параметрами, вызов которого выполнил клиент с ip адресом 127.0.0.1:59333.  	 
В данном случае вызов вышеперечисленных методов означает вычисление точек для построения графиков при параметрах: количество итераций цикла на точку = 4000, количество узлов = [20,30,40,50,60], радиус приема узла = 0,2, последний параметр n означает, что радиус постоянен, а изменяется только количество узлов. 
* 127.0.0.1:59333 - GetGraph1() 
* 127.0.0.1:59333 - GetGraph2() 
* 127.0.0.1:59333 - GetGraph3() 
* 127.0.0.1:59333 - GetGraph4() 
Методы возвращающие значения для построения соответствующих графиков. В данном случае так как было выполнено 5 вызовов TestMode – каждый график будет построен по 5 точкам. 
GetGraph1() – Максимальная степень вершины главной компоненты от 
количества узлов в графе. 
GetGraph2() - Расстояние от центра тяжести многоугольника до центра области от количества узлов в графе. 
GetGraph3() -Количество углов в многоугольнике от количества узлов в графе. 
GetGraph4() -Количество компонент связности от количества узлов в графе. 
Изменить порт и другие сетевые настройки сервера можно путем редактирования файла Settings.conf., расположен в корне с программой 
сервером. По умолчанию в качестве порта используется 2000. 
Приложение работает на платформе NET, для обеспечения работоспособности необходимо наличие предустановленного пакета NET Framework версии 4 и выше. Также приложение сервер для коммуникации с клиентами не должно быть блокировано приложениями брандмауэрами.Для настройки необходимо разрешить активность на выбраном порту или добавить его в исключение. 
 	 
ЗАКЛЮЧЕНИЕ 
 С помощью разработанных программных модулей можно создавать, имитационные модели ad hoc сетей, концептуально представимых в виде графа. Модули содержат в себе необходимый комплекс процедур и функций по редактированию и выполнению различных операций над создаваемыми моделями. Функции по анализу и обработке моделей ad hoc, основанных на графовых структурах, могут работать как с конкретными узлами модели, так и со всей моделью целиком. Так же предусмотрены функции, предоставляющие вывод в удобочитаемом виде созданных ad hoc структур. 
С помощью разработанного клиент –серверного приложения, клиенты могут выполнять построение и исследование моделей ad hoc сетей из любой точки, так как все вычисления выполняются на сервере. Данная коммуникация не требует наличия мощного ПК, тем самым не ограничивает пользователя в количестве, итераций которое необходимо для получения среднего вычисления с минимальной погрешностью. Серверная часть приложения использует разработанные программные модули. Клиенты могут выполнить построение различных графиков зависимостей. 
Использование данных разработок поможет существенно сэкономить время развертывания данных сетей на физическом уровне, определить, в каком расположении сеть связна и имеет наилучшие характеристики. 
СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ 
1  Алгоритмы построения выпуклой оболочки. [Электронный ресурс]  URL: 
http://algolist.manual.ru/maths/geom/convhull/ 
Дата обращения [15 апреля 2016]. 
2  Абрамян М. Э. Visual C# на примерах. // СПб.: БХВ-Петербург, 2008. – 496 с 
3  Винокуров В.М., Пуговкин А.В., Пшенников А.А., Ушарова  Д.Н. 
Маршрутизация в беспроводных мобильных Ad hoc сетях. // СПб: Питер, 
2005.  – 396 с. 
4  Джим Г. Беспроводные сети. Принципы, технологии,  протоколы. // СПб: 
Питер, 2005. – 189 с. 
5  Кровчик Э. Net. Сетевое программирование для профессионалов // Москва 
2005.  – 417 с. 
6  Миков А.И. Графы и грамматики. – Краснодар: Кубанский государственный 
университет, 2014. – 160 с. 
7  Свами М., Тхуласираман К. Графы, сети и алгоритмы. М.: Мир, 1984, - 454 с. 
8  Троелсен Э. Язык программирования C# и платформа .NET // Москва 2011. – 1392 с. 
 
 	 
ПРИЛОЖЕНИЕ А 
 
Графики зависимости математических ожиданий величин 
 
 

 
 
Рисунок А.1 –  График 1 – зависимость максимальной степени вершины 
главной компоненты от радиуса приема узла 
 	 

 
Рисунок А.2  –  График 2 – зависимость расстояния от центра тяжести многоугольника до центра области от радиуса приема узла 
 
 
 	 

 
Рисунок А.3  –  График 3 – зависимость количества углов в многоугольнике от радиуса приема узла 
 
 	 

 
 
Рисунок А.4  –  График 4 – зависимость количества компонент связности от радиуса приема узла 
