1044
ПРОГРАММА КОНТРОЛЯ ДЕЯТЕЛЬНОСТИ СОТРУДНИКОВ ЗА РАБОЧИМ КОМПЬЮТЕРОМ 
3 Описание программы . 
3.1 Описание клиента-наблюдателя . 
----------
Для разработки клиента использовался шаблон проектирования MVC (Model-View-Controller). Данный шаблон проектирования является одним из наиболее популярным и имеет много преимуществ. Основное преимущество – разделение программы на три составляющие: модель, представление, контроллер.
Модель содержит следующие классы.
DataBaseConnection – класс, отвечающий за подключение базы данных, создание таблиц, отправки данных, получения данных, обновления данных с помощью запросов на языке SQL.
MainAnimationTimer – класс, который осуществляет работу клиентанаблюдателя. Данный класс следит за действиями пользователя, делает снимки экрана и отправляет все данные в базу.
ScreenshotMaker – класс, который делает снимки экрана компьютера.
WindowsFactory – класс, который отвечает за получение всех активных процессов компьютера.
В контроллер были включены классы, отвечающие за взаимодействие пользователя и программы, а именно:
ControllerAddUser – класс, отвечающий за взаимодействие пользователя с формой регистрации пользователей.
В представление были включены классы и файлы, отвечающие за отображение интерфейса, а именно:
ClientController – класс, который отвечает за запуск программы, загрузка необходимых файлов и последующей работы программы. sceneAddUser.fxml – файл FXML-разметки, в котором описан интерфейс окна регистрации нового пользователя.
В JavaFX существует несколько вариантов создания пользовательского интерфейса: ручной и графический. Первый способ в основном применяется для небольших, всплывающих окон. Он заключается в ручном написании кода. Второй – более правильный, заключается в вынесении разметки интерфейса в файл с расширением .fxml. Этот файл является разметку, основанный на языке разметки XML. Разметка создается вручную или с помощью программы Scene Builder 2.0, которая генерирует fxml-разметку. В данном случае был выбран второй способ, так как он быстрее и не допускает ошибок в разметке.
После создания разметки интерфейса, его подключают к основному класса. При загрузке класса он обращается к файлу с разметкой, после чего интерфейс отобразится на экране пользователя. В файле разметки указан путь к классу-контроллеру, который обрабатывает события интерфейса (нажатие клавиш, ввод текста и др.) И передает изменения в модель.
Для разработки клиента пришлось прибегнуть к нативным библиотекам, благодаря которым программа может получить информацию о названии запущенной программы, активное окно и др. Для работы программы на Windows всех версий использовалась библиотека JNA (Java native access). Выбор именно этой библиотеки обоснован тем, что в отличие от предыдущей технологии JNI (Java Native Interface), здесь не придется писать библиотеку-оболочку на С. Основное преимущество библиотеки JNA является сокращение времени разработки проекта, если вся необходимая функциональность уже содержится в какой-то стандартной библиотеке Microsoft Windows, или есть посторонний COM-DLL с необходимым набором решений. Данная библиотека обращается к файлам с расширением .dll, в которых хранятся нужные функции.
Клиент-наблюдатель предназначен для регистрации и наблюдения за действиями сотрудника компании за рабочим компьютером. При запуске данного клиента программа запускает класс Client Controller. Данный класс отвечает за создание окна регистрации пользователей и запуска основной логики клиента-наблюдателя. Пример приведен на рисунке 3.1. В классе ClientController идет проверка на первый запуск программы. Проверка осуществляется с помощью запроса в базу данных и проверки на существование таблицы, называется серийным номером материнской платы рабочего компьютера + нижнее подчеркивание + имя пользователя компьютера. Если программа на данном компьютере запущена в первый раз, то она обращается к методу addNewUser () класса ClientController. Этот метод создает новое окно и загружает файл разметки sceneAddUser.fxml. К файлу разметки подключен класс-контроллер ControllerAddUser, который осуществляет обработку событий пользователя. В данном случае контроллер при нажатии на кнопку «Send» проверяет форму на наличие введенных данных, и если данные введены правильно, то программа создает необходимую структуру баз данных для работы, а именно личную таблицу для пользователя, куда пошлют его действия и запись в таблицу пользователей , куда отсылаются данные о пользователе.
Уникальная таблица создается для каждого пользователя с помощью запроса в базу данных:
statement.execute ( "CREATE TABLE` "+ tableName +" `(" +              "` Id` int (10) NOT NULL AUTO_INCREMENT, "+
"` ProgramName` varchar (1024) NOT NULL, "+
"` WorkingTime` varchar (64) NOT NULL, "+
"` WorkingTimeString` varchar (255) NOT NULL, "+
"` 	Date` 	timestamp 	(6) 	NOT 	NULL 	DEFAULT CURRENT_TIMESTAMP (6) ON UPDATE CURRENT_TIMESTAMP (6), "+
"PRIMARY KEY (` id`) "+")
ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET =
utf8; ");
Данный запрос создает таблицу с уникальным названием, которое подставляется в программе на место tableName.
После регистрации программа переходит в режим «наблюдения». В данном режиме программа скрыта от пользователя. Если программа уже была запущена на данном компьютере, то она просто запускает процесс наблюдения.
Рисунок 3.1 – Форма регистрации
Запуская процесс наблюдения, программа обращается к классу MainAnimationTimer. Класс наследуется от класса AnimationTimer, который запускает новую ветку программы. В классе MainAnimationTimer переопределен метод public void handle (long now), который вызывается непрерывно, пока нить запущена. В этом методе описана вся логика слежения за компьютером и отправления событий в базу данных. Метод получает список активных процессов, определяет время работы активного процесса и отправляет в базу данных событие при изменении процесса.
Активное окно выходит с помощью класса WindowsFactory. Класс содержит метод public static void getActiveWindows (), который возвращает массив всех активных программ. В этом классе используется библиотека JNA. В данной библиотеке содержатся методы для работы с нативными библиотеками Windows. В этих библиотеках содержаться значения, которые определяют параметры нужного окна. Указав нужные параметры в методе программа получает список всех активных процессов. Данный список записывается в массив в порядке от нового активного процесса.. Таким образом, первый элемент массива будет фронтовым активным окном и будет указано в таблице. После получения процесса управления передается в класс MainAnimationTimer, где происходит проверка: если текущий активный проецсс изменился, то создается новое событие, состоящее из имени пользователя, имени программы, даты и времени работы предыдущего окна и отправляется в базу данных. При изменении текущего активного процесса автоматически делается снимок экрана, который отправляется на сервер в созданную для пользователя директорию. Все методы класса WindowsFactory являются статичными и для их использования не нужно специально создавать объект.
Скриншоты делаются с помощью класса ScreenshotMaker. Для того, чтобы сделать снимок экрана, нужно вызвать метод public void makeScreenshot (String screenName). В параметр вводится имя снимка экрана, которое подставляется динамично. Снимок экрана делается с помощью библиотеки AWT.
String 	fullScreenName 	= 	path 	+ 	screenName 	+ 	POINT 	+
FORMAT_SCREEN;
Robot robot = new Robot ();
BufferedImage screenShot = robot.createScreenCapture (new Rectangle (Toolkit.getDefaultToolkit (). GetScreenSize ()))
ImageIO.write 	(screenShot, 	FORMAT_SCREEN, 	new 	File
(fullScreenName))
Код выше делает снимок экрана. Первая строка получает имя файла и директорию, в которой он будет храниться. Далее создается объект класса Robot, в списке методов которого является метод для создания снимка экрана. Этот метод захватывает прямоугольную область с размерами экрана и записывает его как поток байтов, после чего создается файл и в него записываются полученные байты. Для изменения пути сохранения снимка экрана используется метод updateName (String pathToSaveScreen), где параметром вводится абсолютный или относительный путь.