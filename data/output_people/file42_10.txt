801
РАЗРАБОТКА ПРОГРАММНОГО АГЕНТА ДЛЯ ИНФОРМАЦИОННОГО ПОИСКА В СРЕДЕ ИНТЕРНЕТ 
2 Парсинг сайта . 
2.5 Многопоточные приложения . 
----------
Парсинг  будем осуществлять в отдельном потоке. Рассмотрим вопросы создания многопоточных приложений.
Многопоточность позволяет приложениям разделять задачи и работать над каждой независимо. Это позволяет  максимально эффективно задействовать процессор и пользовательское время. Однако, следует отметить,  не следует  выбирать многопточность для всех приложений,  так как при этом работа некоторых из них может даже замедлиться.
Поток является единицей обработки данных, а многозадачность — это одновременное исполнение нескольких потоков. Существует два вида многозадачности — вытесняющая (preemptive) и  совместная (cooperative). Совместную многозадачность поддерживали самые ранние версии Microsoft Windows. Каждый поток при этом  отвечал за возврат управления процессору, чтобы тот мог обрабатывать  другие потоки.
Однако позже Microsoft Windows NT и  затем  Windows 95, Windows 98 и Windows 2000 стали поддерживать вытесняющую многозадачность, которую поддерживала OS/2. Процессор  при этом отвечает за выдачу каждому потоку  кванта времени (timeslice) – определенного количества времени, в течение которого поток может выполняться.   Далее процессор переключается между разными потоками, выдавая каждому потоку его квант времени. Программист в этом случае может не заботится о том, как и когда возвращать управление, в результате чего могут работать и другие потоки.
Следует отметить, если вы работаете на однопроцессорной машине,  даже в случае вытесняющей многозадачности, все равно в любой момент времени реально будет исполняться только один поток. Поскольку интервалы между переключениями процессора от процесса к процессу измеряются миллисекундами, возникает иллюзия многозадачности. Чтобы несколько потоков на самом деле работали одновременно,  необходимо работать на многопроцессорной машине,  разработав  соответствующую программу.
Неотъемлемый атрибут потоков — переключение контекста (context switching).  С  помощью аппаратного таймера  процессор определяет момент окончания кванта, выделенного для данного потока. Когда аппаратный таймер генерирует прерывание, процессор сохраняет в стеке содержимое всех регистров для данного потока. Затем процессор перемещает содержимое этих  регистров в структуру данных CONTEXT. При необходимости переключения обратно на поток, выполнявшийся прежде, процессор выполняет обратную процедуру и восстанавливает содержимое регистров из структуры CONTEXT, ассоциированной с потоком. Весь этот процесс называется переключением контекста.
Рассмотрим создание многопоточного приложения с помощью языка C#.
Основной функционал для использования потоков в приложении сосредоточен в пространстве имен System.Threading. Создание потоков и управление ими осуществляется с помощью класса System. Threading. Thread.
Класс Thread определяет ряд методов и свойств, которые позволяют управлять потоком и получать информацию о нем. Основные свойства класса:
1)  Статическое свойство CurrentContext позволяет получить контекст,
в котором выполняется потоки.
2)  Статическое свойство CurrentThread возвращает ссылку на выполняемый поток.
3)  Свойство IsAlive указывает, работает ли поток в текущий момент.
4)  Свойство IsBackground указывает, является ли поток фоновым.
5)  Свойство Name содержит имя потока.
6)  Свойство Priority хранит приоритет потока – значение перечисления ThreadPriority.
7)  Свойство ThreadState возвращает состояние потока - одно из значений перечисления ThreadState.
Некоторые методы класса Thread:
1)  Статический метод GetDomain возвращает ссылку домен приложения.
2)  Статический метод GetDomainId возвращает id домена приложения, в котором выполняется текущий поток.
3)  Статический метод Sleep останавливает поток на определенное количество миллисекунд.
4)  Метод Abort уведомляет среду CLR о том, что надо прекратить поток, однако прекращение работы потока происходит не сразу, а только тогда, когда это становится возможно. Для проверки завершенности потока следует опрашивать его свойство ThreadState.
5)  Метод Interrupt прерывает поток на некоторое время.
6)  Метод Join блокирует выполнение вызвавшего его потока до тех пор, пока не завершится поток, для которого был вызван данный метод.
7)  Метод Resume возобновляет работу ранее приостановленного потока.
8)  Метод Start запускает поток.
9)  Метод Suspend приостанавливает поток.
При переключении процессора по окончании выделенного потоку кванта времени, процесс выбора следующего потока, предназначенного для исполнения, далеко не произволен. У каждого потока есть приоритет, указывающий процессору, как должно планироваться выполнение этого потока по отношению к другим потокам системы. Для потоков, создаваемых в период выполнения, уровень приоритета по умолчанию равен Normal. Потоки, созданные не в период выполнения, сохраняют свой исходный приоритет. Для просмотра и установки этого значения служит свойство Thread.Priority. Установщик свойства Thread.Priority принимает аргумент типа Thread. ThreadPriority. Приоритеты потоков располагаются в перечислении ThreadPriority: Lowest, BelowNormal, Normal, AboveNormal, Highest. По умолчанию потоку задается значение Normal. Однако мы можем изменить приоритет в процессе работы программы. Например, повысить важность потока, установив приоритет Highest. Среда CLR будет считывать и анализировать значения приоритета и на их основании выделять данному потоку то или иное количество времени.
Статусы потока содержатся в перечислении ThreadState:
Aborted: поток остановлен, но пока еще окончательно не завершен.
AbortRequested: для потока вызван метод Abort, но остановка потока еще не произошла.
Background: поток выполняется в фоновом режиме.
Running: поток запущен и работает (не приостановлен).
Stopped: поток завершен.
StopRequested: поток получил запрос на остановку.
Suspended: поток приостановлен.
SuspendRequested: поток получил запрос на приостановку.
Unstarted: поток еще не был запущен.
WaitSleepJoin: поток заблокирован в результате действия методов Sleep или Join.
В процессе работы потока его статус многократно может измениться под действием методов. Так, в самом начале еще до применения метода Start его статус имеет значение Unstarted. Запустив поток, мы изменим его статус на Running. Вызвав метод Sleep, статус изменится на WaitSleepJoin. А применяя метод Abort, мы тем самым переведем поток в состояние AbortRequested, а затем Aborted, после чего поток окончательно завершится.