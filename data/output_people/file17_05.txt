217
Изучение организации многопоточности в Java и Python
2. Средства реализации многопоточности в Python 
2.1. Threading 
----------
В данном модуле есть два варианта создания потоков:
1) При помощи вызова функции - threading.Thread(target=, args=)
2) При помощи вызова класса – MyThread(args).start()
Создание класса является более надёжным способом взаимодействия с потоками, к тому же с помощью этого класса легче находить ошибки в отладке программы.
Класс должен иметь метод run() и __init__. В методе run() прописывается все действия, которые должен исполнить каждый поток этого класса. Метод start() запускает экземпляр класса MyThread (см. рисунок 5).
Рисунок 5 – Пример программы с классом
Чтобы управлять потоками, нужно следить, как они себя ведут. В threading для этого есть специальные методы:
current_thread() — возвращает информацию о потоке (имя и его уникальный идентификатор), который вызвал функцию.
active_count() — возвращает количество активных потоков.
enumerate() — возвращает список активных потоков.
Можно управлять потоком через методы класса:
is_alive() — возвращает true, если поток активен, иначе false
getName() — возвращает имя потока;
setName(any_name) — задаём имя потоку
Обычно Python-приложение не завершается, пока работает хоть один его поток. Но есть особые потоки, которые не мешают закрытию программы и останавливается вместе с ней. Их называют демонами (daemons). Проверить, является ли поток демоном, можно методом isDaemon(). Если является, метод вернёт истину.
Назначить поток демоном можно при создании — через параметр “daemon=True” или аргумент в инициализаторе класса.
thread0 = Thread(target=target_func, kwargs={‘x’:10}, daemon=True)
Можно демонизировать и уже существующий поток методом setDaemon(daemonic).