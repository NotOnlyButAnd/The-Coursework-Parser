639
ИССЛЕДОВАНИЯ МЕТОДОВ ПРИНЯТИЯ РЕШЕНИЙ
3. РЕАЛИЗАЦИЯ И ТЕСТИРОВАНИЕ АЛГОРИТМА 
----------
Рассмотрим пример построения дерева принятия решений.
Предположим, что нас интересует, выиграет ли команда «ФКТиПМ» свой следующий матч. Результат зачастую зависит от ряда параметров, возьмем несколько основных, так как:
* выше или ниже в турнирной таблице находится соперник;
* пропускают ли матч, основные(лидеры) игроки команды;
* погодные условия;
* дома ли проводится матч.
Допустим у нас есть некоторая статистика, по итогам прошлых игр, из которых были получены данные указанные в табл. 1.
Таблица 1. Как играет «ФКТиПМ»
Соперник
Место пр. матча
Погодные условия
Лидеры
Победа
Выше
Дома
Отрицательные
На месте
Нет
Выше
Дома
Положительные
На месте
Да
Выше
Дома
Положительные
Пропускают
Да
Выше
В гостях
Отрицательные
На месте
Нет
Ниже
Дома
Положительные
Пропускают
Да
Ниже
В гостях
Положительные
Пропускают
Нет
Ниже
Дома
Отрицательные
Пропускают
Да
Ниже
В гостях
Положительные
На месте
?
Зная, эти факторы попробуем составить дерево принятия решений. В узлах, не являющихся листьями, находятся атрибуты, по которым различают случаи. По ребрам будем спускаться чтобы классифицировать имеющиеся случаи. Далее просто записываем атрибуты в порядке, указанном в табл. 1. Тогда у нас получается дерево, изображенное на рис. 4.
Рис. 4. Вариант дерева принятия решений
Построенное дерево, конечно, дает правильный результат, но не идеально т.к. его глубина равна четырем. Чтобы это исправить можно взять в качестве корня другой атрибут, например, поместим туда вопрос о погоде. В случае если, погода положительна, то следующим атрибутом будет положение соперника в турнирной таблице, а в случае, отрицательной погоды, будет смотреть на атрибут проходит ли матч дома. В этом случае его глубина будет равна двум.
Рис 5. Оптимальное дерево принятия решений
Теперь нужно обучить дерево, так, чтобы оно вбирало оптимальное решение. Это требование формализуется посредствам энтропии.
Определим оптимальный атрибут, вычислим исходную энтропию
(15)
Теперь определим приросты информации для различных атрибутов:
Из данных вычислений отчетливо видно, что мы выбрали не слишком удачный атрибут для корня дерева.
Теперь сведем все то, о чем рассуждали в единый рекурсивный алгоритм для построения дерева принятия решений.
Для реализации возьмем алгоритм ID3 на языке Python.
Рассмотрим псевдокод алгоритма:
ID3 (A,S,Ϭ) , где А – множество элементов, S – свойство, которому должны удовлетворять некоторые элементы множества А, Ϭ – множество, в котором хранится прирост информации, каждого атрибута.
1.  Создать корень дерева
2.  Если условие S выполняется на всех элементах A, поставить в корень метку 1 и выйти.
3.  Если S не выполняется ни на одном элементе А, поставить в корень метку 0, выйти.
4.  Если Q= Ø, то:
a)  если S выполняется на большей части или половине множества А, поставить в корень метку 1 и выйти
b)  если S выполняется на части, которая меньше половины A, поставить в корень метку 0 и выйти.
5.   Выбрать Q ∈ Ϭ, для которого Gain(A, Q) максимален.
6.   Метку Q поставить в корень.
7.   Для каждого значения q атрибут Q:
a)  добавить нового потомка корня и пометить соответствующее исходящее ребро меткой q;
b)  если в А нет примеров, для которых Q принимает значение q, то пометить этого потомка в зависимости от того, на какой части А выполняется S (возврат к пункту 4);
c)  иначе реализовать ID3(A, S, Ϭ \ {Q} ) и добавляем его результат, как поддерево с корнем в этом потомке.
У данного алгоритма реализации, есть несколько значительных преимуществ таких как:
* обработке ситуации, когда одному и тому же набору атрибутов соответствуют несколько случаев с разными исходами (за решение данной проблемы отвечает пункт 4);
* обработке ситуации, когда у атрибута может встретиться несколько вариантов, к тому же, может так произойти, что какой-то из этих вариантов не реализуется, в таком случае мы заполняем соответствующий лист в зависимости от того, каких исходов было больше в его предке (за это отвечает пункт 7b).
Программа обрабатывает только бинарные атрибуты. Рассмотрим формат входного файла:
* число атрибутов n;
* строки формата, количество строк равно n ([Название атрибута], [Положительное значение], Отрицательное значения]);
* название основного атрибута;
* m – число тестовых примеров;
* строки формата ([атрибут1 = значение1], …, [атрибутn  = атрибутn]).