516
РЕАЛИЗАЦИЯ И СРАВНИТЕЛЬНЫЙ АНАЛИЗ МЕТОДОВ МАШИННОГО ОБУЧЕНИЯ ДЛЯ КЛАССИФИКАЦИИ МУЗЫКАЛЬНЫХ КОМПОЗИЦИЙ ПО ЖАНРАМ
2 Описание используемых методов, функций и библиотек 
2.3 Возможности Python по анализу данных 
----------
Для исследования данных и реализации алгоритма классификации используется язык программирования Python, у которого в настоящее время имеется большое количество библиотек и фреймворков для реализации машинного обучения, анализа данных и их визуализации. В работе используются облачный сервис Google Colaboratory. Это новый облачный сервис, направленный на упрощение исследований в области обучения нейронных сетей и deep learning. Используя Colaboratory, можно получить удаленный доступ к машине с подключенной видеокартой и процессором Tesla K80, что приносит большую пользу, когда приходится обучать нейронные сети на больших объёмах данных, или, когда возникают проблемы с установкой и подключением библиотек в интерпретаторах на обычном компьютере. Можно считать, что она является некоторым аналогом google-документов для Jupyter Notebook. В Google Colaboratory содержатся все библиотеки Python, необходимые для написания программ визуализации данных, для сложных математических расчётов, при создании различных обучаемых моделей, глубоких нейронных сетей и многого другого. Также в ней присутствует функция разбиения написанного кода на независимые блоки, вследствие чего появляется возможность запуска отдельных частей программы, что очень удобно для выявления ошибок в коде и при отладке программы. Этот функционал получилось реализовать, потому что Python является интерпретируемым языком (то есть команды исполняются построчно).
Для визуализации данных в работе используется метод pyplot из библиотеки matplotlib.
В качестве пакета для работы со звуком было решено выбрать Librosa. Она позволяет создать полноценную систему извлечения музыкальной информации. Также её преимущества в том, что Librosa предназначена именно для обработки музыки и хорошо документирована.
Машинное обучение осуществляется с помощью библиотеки Scikit-Learn, в которой реализовано большое количество линейных и нелинейных способов машинного обучения. Также в Scikit-Learn содержатся средства для загрузки и нормализации данных, отбора признаков, оптимизации параметров алгоритма, оценки качества работы алгоритма.
Реализация метода логистической регрессии осуществляется с помощью объекта LogisticRegression библиотеки Scikit-Learn. Функция LogisticRegression() создаёт модель логистической регрессии. Она имеет параметры, настраиваемые под определённую задачу классификации. В нашем случае параметр multi_class='multinomial', так как производится полиномиальная классификация. Параметр max_iter отвечает за максимальное количество итераций и по умолчанию имеет значение, равное 100. Если классификация не бинарная, то следует указать больше итераций, например, 1000. Параметр penalty='l2' позволяет выбрать функцию регуляризации логистических потерь, и в случае, когда количество классов больше двух, должен быть равен ‘l2’. Все остальные параметры можно на первых порах оставить такими же, какие они есть, но после получения результатов классификации некоторые из них, скорее всего, будет необходимо изменить для улучшения качества работы метода.  Чтобы обучить модель, нужно вызвать функцию fit(X,y), где X – это двумерный массив признаков, y – метка класса для каждого набора описаний объекта из X. Также в работе используется библиотека NumPy —  библиотека с открытым исходным кодом для языка программирования Python. Основной возможностью этой библиотеки является поддержка многомерных массивов (включая матрицы) и поддержка высокоуровневых математических функций, предназначенных для работы с многомерными массивами. Эта библиотека использует параллельные вычисления, и содержит алгоритмы для решения задач линейной алгебры. Numpy входит в библиотеку для научных вычислений SciPy.
Для работы с каталогами, где хранятся данные для обучения и тестирования в виде файлов в формате .wav применяются средства пакета os. Модуль os предоставляет множество функций для работы с операционной системой, причём их поведение, как правило, не зависит от ОС, поэтому программы остаются переносимыми. В данной реализации с помощью os проверяется наличие каталогов, подкаталогов и файлов в хранилище данных.