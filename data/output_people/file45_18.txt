1649
РАЗРАБОТКА РАСПРЕДЕЛЕННОЙ СИСТЕМЫ ИСПОЛЬЗОВАНИЯ УДАЛЕННЫХ ВЫЧИСЛИТЕЛЬНЫХ РЕСУРСОВ
2 Разработка распределенной вычислительной системы . 
2.4 Реализация . 
2.4.4 Реализация программы . 
----------
Рассмотрим с помощью UML диаграмм последовательностей общий механизм взаимодействия компонентов системы CRDS.
Итак, сначала представим общую схему взаимодействующих между собой компонент, для осуществления соединения и передачи задачи, написанной пользователем, с одного компьютера на другой. Данная схема была представлена на рисунках 3-4 в разделе 2.2. Теперь, основываясь на схеме рисунка 4, рассмотрим взаимодействия между группами компонентов.
Сперва, рассмотрим подробно взаимодействие объекта класса ComputeEngine с ClientImpl и ServerImpl, при этом опустим тонкости работы ClientImpl и ServerManager (Рисунок 5).
Рисунок 5 – Взаимодействие ComputeEngine с ClientImpl и ServerImpl
При запуске пользователем программы, которая создает экземпляр класса ComputeEngine, при указании в качестве параметров объект класса, реализующего интерфейс Task, объект ComputeEngine получает у RMI регистра ссылку на объект ClientImpl.
Затем, когда пользовательская программа активирует вычислитель методом start(), в объекте создается экземпляр класса ClientConnectorThread и запускает его как поток, конструктору которого передаются ссылка на ClientImpl, объект задачи, путь к файлам реализации задачи и количество памяти необходимое для выполнения. ClientConnectorThread выполняет запрос к ClientImpl - bindToServer(…), у которого в качестве параметров является путь к файлу реализации задачи и количество необходимой памяти, в ответ от ClientImpl получает индекс потока, который занимается поиском и подключением к менеджеру сервера. После получение индекса потока от ClientImpl, ClientConnectorThread вызывает getURLOfServer() у ClientImpl, в параметры которого передаёт индекс потока и ожидает ответа. При получении ответа по принятому адресу ServerImpl выполняется соединение помощью LipeRMI, и выполняется отправка задачи серверу, который уже готов к её выполнению.
Спустя некоторое время программе пользователя понадобились результаты вычислений задачи, отправленной ComputeEngine. Для получения результатов в ComputeEngine есть два метода – один синхронный (getResult()), другой асинхронный (getAsynResult()). В описанном примере используется синхронный вызов, который приостанавливает работу программы пользователя на время выполнения задачи и получения её результата. При вызове одного из методов получения результата ComputeEngine запрашивает ссылку на удаленный объект сервера, методом getServer() у потока ClientConnectorThread. После чего выполняется запрос серверу getResult() (если в ComputeEngine вызван метод getAsynResult(), то к серверу выполняется соединение по аналогичному запросу), возвращающий результат выполнения задачи.
Таким образом, пользователь получает возможность программировать программы, через которые с помощью ComputeEngine выполняются отправки заданий на выполнение. Важной особенности описанной реализации является то, что ComputeEngine позволяет программе работать далее, не загружая её на этапе поиска и соединения с сервером, выполнения задачи. Стоит отметить возможность пользователя самому управлять методом получения задачи, как синхронно, так и асинхронно.
На основе выше описанного примера было получено представление как работает экземпляр класса ComputeEngine и его компоненты, далее рассмотрим работу не менее важного компонента – это ClientImpl (Рисунок
6).
Рисунок 6 – Взаимодействие ClientImpl с ServerManagerImpl
В данном случае нет необходимости рассматривать действия со стороны пользовательской программы и ComputeEngine, возьмем только ClientConnectorThread и предположим, что от этого элемента был инициирован вызов у ClientImpl метода bindToServer, который был описан ранее. После вызова данного метода ClientImpl осуществляет поиск среди потоков ConnectThread свободный, если свободного потока не найдется, то запрос будет добавлен в очередь queueOfTasks типа Queue<String>, где запрос представляется в виде строки структуры:
“<путь к реализации задачи>    <требуемая память>”   	 	       (1)
Итак, когда ClientImpl находит свободный поток или пришла очередь задачи из очереди, методом свободного потока ConnectThread setTask(String classPath, int memoryForTask,  ArrayList<URL> webServers), где classPath – путь к реализации задачи, memoryForTask – память для задачи и webServers – список адресов веб серверов, устанавливаются параметры и поток запускается.
При запуске, поток ConnectThread, изначально выполняет метод getServerManager(int countOfMemory) класса WebConnector, который формирует запрос в формате JSON с помощью класса WebRequest (не указан на рисунке, так как не выполняет важных функций), затем устанавливает связь с одним из веб серверов и отправляет POST запрос с JSON файлом. В ответ от сервера приходит файл формата JSON, содержащий список параметров для подключения к удаленному менеджеру серверов.
Форматы JSON-запросов и методы класса WebRequest создающие их.
Метод применяется для регистрации менеджера серверов в веб сервере.
public static String connect(int port, int memory)
{ return
String.format("{\"method\":\"connect\",\"port\":%d,\"memory\":%d}",             	port, memory);
}
Метод применяется для получения списка параметров менеджеров серверов в веб сервере.
public static String getURLOfServers(int memory)
{             return String.format("{\"method\":\"get_servers\",\"memory\":%d}",                                                                     memory);
}
Метод применяется для удаления параметров менеджера серверов с баз данных веб сервера.
public static String disconnect()
{      return "{\"method\":\"disconnect\"}";  }
Параметры менеджера серверов хранятся на веб сервере в базе данных, доступ к которой осуществляется через PHP скрипты, формирующий ответ на запрос. В нашем случае ответ будет содержать массив из трех параметров – это ip адрес компьютера 2, порт для подключения к ServerManagerImpl и максимальная память, предоставляемая им. Выборка нужных менеджеров осуществляется с помощью SQL запросов к базе данных со стороны PHP скрипта. Итак, WebConnector по полученным параметрам получает доступ к удаленному объекту с помощью LipeRMI и возвращает полученную ссылку ConnectThread.
Рассмотрим случай, когда у пользователя отсутствует соединение с интернетом или же нет доступных веб серверов. В данной ситуации WebConnector возвращает значение null, после чего ConnectThread повторяет такой же вызов метода getServerManager, но уже у LocalConnector, который работает с устройствами по локальной сети. LocalConnector выполняет широковещательную рассылку UDP-пакетов, содержащих одно число – количество требуемой памяти. В качестве приёмника UDP-пакетов выступает LocalRecieverThread, который принимает пакет, сравнивает полученное значение со значением, установленным ServerManagerImpl, и отправляет ответ с подтверждением в виде UDP пакета, содержащего номер порта менеджера серверов. LocalRecieverThread принимает подтвержденный ответ, получает ссылку на удаленный объект менеджера и отправляет её в качестве ответа ConnectThread.
Описанные классы WebConnector и LocalConnector имеют общий интерфейс Connector, а также при вызове метода getServerManager резервируют в нём сервер методом reserveOfServer(String host,int countOfMemory), где host – это адрес текущего компьютера, от которого идет запрос.
ConnectThread, получив ссылку на удаленный ServerManagerImpl, получает индекс выделенного сервера от WebConnector/LocalConnector, затем упаковывает в Zip-архив файлы, на которые указывает переменная classPath,
и выполняет вызов метода удаленного менеджера серверов downloadClassForTask(byte[] zipOfClassFiles, int indexOfServer), в котором передает массив байтов созданного архиватором ZipArchivator и индекс сервера. В ответ ConnectThread получает URI для подключения к выделенному серверу.
Через некоторое время ClientConnectorThread выполняет запрос getURLOfServer(int index) у ClientIml, тот по индексу index находит поток и делает запрос getURLOfServer, полученный URI клиент отправляет ClietnConnectorThread. После этого этапа клиент не участвует в дальнейших действиях между приложением пользователя и сервера.
Также следует отметить, что данная реализация выполняет выделение сервера в любом случае. Так если нет интернета, то поиск происходит по локальной сети, однако, если в локальной сети не нашлось задачи, она будет запущена на сервере компьютера данного пользователя. Таким образом обеспечивается гарантия выполнимости поставленной задачи.
Итак, на основе рассмотренных примеров и диаграмм был представлен основной функционал программы CRDS, а именно, класс ComputeEngine, с помощью которого пользователь может отправить свою задачу на выполнение удаленной машине, без необходимости ожидания её завершения. Были описаны основные методы классов ComputeEngine, ClientImpl, ClientConnectorThread, ConnectThread, LocalConnector, WebConnector, WebRequest, ServerManagerImpl, ServerImpl.
При описании алгоритмов взаимодействия между удаленными объектами, не было учтено одно, после завершения работы ServerImpl и отправки пользователю результата, сервер остается запущенным, в силу того, что при привязке ссылки на объект в RMI регистре, этот объект находится в отдельном потоке, который не является “демоном” и, следовательно, программа не завершится, пока её не завершат. Для закрытия программы ServerImpl применяется класс ScheduledTask, который отправляет запрос getPortsOfServers() локальному ServerManagerImpl, от которого получает список портов от запущенных серверов. Затем, последовательно перебирая порты и подключаясь к серверам с помощью LipeRMI, ScheduledTask проверяет статусы серверов (класс ServerStatus) и если статус равен COMPLETE или ERROR, то индекс данного сервера помещается в список. После описанной процедуры список отправляется ServerManagerImpl методом closeServers(ArrayList<Integer> listOfServers), который по указанным индексам закрывает приложения серверов, вызовом метода класса ProcessController destroy(), после чего сбрасываются все настройки класса ServerInfo, используемого менеджером серверов как информационного объекта и содержащего в списке listOfServers. Описанный сценарий изображен на рисунке 7.
Рисунок 7 – Процесс проверки и завершения работы ServerImpl
Следует учесть, то что ScheduledTask запускается таймером из класса CRDS с определенным константой интервалом. Также все файлы, которые передаются со стороны клиента и используются сервером, по завершению работы автоматически удаляются.
Помимо основного функционала в приложении CRDS имеется
возможность контроля. Для того чтобы получать сведения о системе или изменять её параметры был разработан класс CRDSController.
Экземпляр объекта CRDSController позволяет программисту вызывать следующие методы для взаимодействия с системой CRDS:
а) boolean setMemoryForServers(int countOfMemory) – установка памяти, выделяемой серверами по умолчанию. Возвращает false в случае ошибки или недопустимого значения параметра.
б) boolean setMemoryForServer(int countOfMemory, int indexOfServer) – установка количества памяти для сервера под индексом indexOfServer.
Возвращает false в случае ошибки или недопустимого значения параметра.
в) int getMemoryForServers()  - получение количества памяти
установленной для серверов по умолчанию.
г) int getMemoryForServer(int indexOfServer) – получение количества
памяти для сервера под указанным индексом.
д) boolean setMemoryForTasks(int countOfMemory) – установка количества памяти по умолчанию для задач пользователя. Возвращает false в случае ошибки или недопустимого значения параметра.
е) int getMemoryForTasks() – получение количества памяти по
умолчанию для задач пользователя.
ж) boolean setCountOfServers(int countOfServers) – установка нового значения количества серверов, выделяемых менеджером серверов.
Возвращает false в случае ошибки или недопустимого значения параметра.
и) 	int 	getCountOfServers() 	– 	получение 	количества 	серверов,
выделяемых менеджером серверов.
к) boolean setCountOfTasks(int countOfTasks) – установка нового значения количества задач, обрабатываемых клиентом без очереди.
Возвращает false в случае ошибки или недопустимого значения параметра.
л) int getCountOfTasks() – получение количества задач, обрабатываемых
клиентом без очереди.
м) boolean setListOfWebServers(ArrayList<URL> webServers) – установка нового списка веб серверов. Возвращает false в случае ошибки или недопустимого значения параметра.
н) ArrayList<URL> getListOfWebServers() – получение списка веб
серверов, используемых системой.
п) boolean addWebServer(URL webServer) – добавление нового веб сервера в существующий список системы. Возвращает false в случае ошибки или недопустимого значения параметра.
р) boolean removeWebServer(URL webServer) – удаление указанного веб сервера из списка системы. Возвращает false в случае ошибки или недопустимого значения параметра.
с) ServerStatus getStatusOfServer(int indexOfServer) – получение статуса
сервера по указанному индексу.
т) ArrayList<ServerStatus> getStatusesOfServers() – получение списка статусов всех серверов менеджера серверов.
у) TaskStatus getStatusOfTask(int indexOfTask) – получение статуса
задачи по указанному индексу.
ф) ArrayList<TaskStatus> getStatusesOfTasks() – получение списка
статусов всех задач обрабатываемых клиентом.
void setLocalSever(boolean flag) – установка флага применения в системе поиска по локальной сети.
х) 	boolean 	isUsedLocalServers() 	– 	получение 	значения 	флага
определяющего используется ли в системе поиск по локальной сети.
Все описанные выше методы позволяют изменять состояние компонентов системы. Так как данный инструмент является дополнением к системе и не является основным инструментом, принципы работы которого описаны в разделе 2.2, то полный обзор логической структуры отсутствует в данном контексте. Реализации классов ClientImpl и ServerManagerImpl приведены в ПРИЛОЖЕНИЕ C.