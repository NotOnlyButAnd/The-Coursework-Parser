913
«АРХИТЕКТУРА И МЕТОДЫ РАЗРАБОТКИ WEB-СЕРВИСОВ» 
2 ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ SOAP WEB-СЕРВИСА 
2.2 Реализация поставленной задачи 
----------
Наша программа состоит из пяти частей:
- Index.js
- Client.js
- Descr.wsdl
- Package.json
- Package-lock.json
Рассмотрим создание, свойства и роль каждой части чуть подробнее.
1) Index.js поднимает сервер и по описанию WSDl-файла Descr.wsdl создает наш SOAP-сервис. Для реализации данных задач необходимо подключить два модуля http и soap, где первый отвечает за сервер, который мы будем поднимать, а второй за организацию SOAP-сервиса.
Далее определим наш сервис var service, назовем его Some_service и зададим порт Some_Port, который будет содержать четыре вычислительных функции: sumNums, minusNums, differenceNums и divisionNums. Установим синхронизацию с WSDL-файлом readFileSync(‘.Descr.wsdl’, ‘utf8’) в переменную «xml», укажем порт 3030 и, наконец, создадим сервер при помощи server = http.createServer, дополнительно описав ситуацию 404: Not Found.
В конце задаем наш SOAP Web-сервис на данный сервер выражением soap.listen(server, ‘/’, service,xml). Теперь, если задание сервера, работоспособность заданных функций и описание Web-сервиса корректны, мы можем поднять наш сервис в среде выполнения командой node index.js и проверить его работоспособность, перейдя в браузере по ссылке http://localhost:3030/.
2) Client.js отвечает за вызов функций, описанных в нашем сервисе. Здесь также нужно подключить модуль «soap» для создания клиента «soapClient» функцией soap.createClient, где опишем вывод ошибочного сообщения при некорректности запроса или целостности и работоспособности проекта в целом, а также вызов наших функций в ином случае. Для каждой функции также отдельно зададим вывод ошибки в ошибочной ситуации.
Теперь, при вызове данного файла командой node client.js (в это время сервер index.js должен быть запущен), мы увидим такой ответ:
Для того, чтобы убедиться в работе SOAP, добавим вывод тела SOAP-запросов и SOAP-ответов наших функций, добавив две такие строки:
client.on('request',(body)=>{console.log(body.replace(/>/g, ">\n"))}) – вывод тела запроса; replace помогает преобразовать вывод в более пригодный для показа вид.
client.on('response',(body)=>{console.log(body.replace(/>/g, ">\n"))}) – вывод тела ответа.
Для наглядности вызовем node client.js только для сложения, так как для всех четырех функций результат будет объемным:
Сначала идет запрос, где мы видим две наши переменные firstNum и secondNum, равные 2 и 4 соответственно, вызванные вместе с функцией sumNums (мы можем это увидеть, посмотрев на <ths: sumNums>).
Далее мы вывели SOAP-ответ, где «value» несет результат выполнения функции сложения двух чисел, который можно увидеть под ответом. «Value» является частью сообщения sumNumsResponse, которое является шаблоном ответа на запрос функции сложения двух чисел и описано в WSDL-файле. Об описании сообщений рассмотрим далее.
3) Descr.wsdl - WSDL-файл, полностью описывающий наш Web-сервис, его работу и доступ к нему извне. По сути, он является основополагающей SOAP Web-сервиса и работать с ним нужно аккуратно. Основное предназначение описания было рассмотрено выше, теперь подробнее рассмотрим элементы WSDL, их назначение и опишем наш сервис.
Документ содержит в себе такие элементы, как: definitions, types, message, operation, portType, binding, port и service. Структура WSDL-файла указана на рисунке 3. Теперь рассмотрим каждый элемент подробнее.
Рисунок 3 – Структура WSDL документа
- definitions.
Содержит используемые для сообщений определения XML. Поле name является необязательным, xmlns: tns обозначает пространство имен, xmlns: soap определяет SOAP протокол, xmlns:xsd является стандартным определением пространства имен, которое используется для указание специфичной информации для SOAP. TargetNamespace является «логическим именем» документа WSDL, так как WSDL могут использовать другие WSDL, а targetNamespace поможет не конфликтовать им между собой.
- types.
Предоставляет информацию о любых сложных типах данных, используемых в WSDL. Если сложных типов в описании нет, то WSDL документ не должен иметь раздел типов, как в нашем сервисе.
- message.
Абстрактное определение передаваемых данных. В нашей программе мы описали восемь сообщений по два на каждую функцию, где одно сообщение создано для запроса, другое для ответа.
Рассмотрим два таких сообщения для функции сложения двух чисел.
<message name = "sumNumsRequest">
<part name = "firstNum" type = "xsd:string"/>
<part name = "secondNum" type = "xsd:string"/>
</message>
Данное сообщение отвечает за построение SOAP-запроса, его имя sumNumsRequest. Тип наших переменных указан string, однако при вычислении мы проводим конвертацию string в number.
<message name = "sumNumsResponse">
<part name = "value" type = "xsd:string"/>
</message>
Данное сообщение отвечает за построение SOAP-ответа, его имя sumNumsResponse мы можем увидеть в теле SOAP-запроса. Значением сообщения является переменная value типа string, которая содержит в себе ответ запрошенной функции (в нашем случае – сложения).
- operation.
Абстрактное описание действия, поддерживаемого сервисом. Содержит в себе два сообщения, одно из которых отвечает за вход данных input, другое за выход output. Возвращаясь к нашему примеру, input – sumNumsRequest, output – sumNumsResponse. Раздел operation содержится в portType и их может быть несколько.
- portType.
Набор операций, поддерживаемых одной или несколькими точками (портами). В нашем Web-сервисе portType содержит в себе четыре элемента operation. Для наглядности ниже приведен пример portType для одной только функции сложения, где имя порта Some_PortType.
<portType name = "Some_PortType">
<operation name = "sumNums">
<input message = "tns:sumNumsRequest"/>
<output message = "tns:sumNumsResponse"/>
</operation>
</portType>
- binding.
Данный элемент описывает вызов операций путем указания конкретного протокола (в нашем случае SOAP) и спецификаций формата данных сообщений. Необходимо также указать название порта, в котором находится описываемая функция и само имя элемента binding для дальнейшего указания в элементе port.
- port.
Указывается одна конечная точка в качестве адреса для привязки, определяя, таким образом, единственную конечную точку связи. Элемент port содержится в элементе service. Помимо этого, в port указывается адрес, где будет расположен сервис.
<port binding = "tns:Some_Binding" name = "Some_Port">
<soap:address location = "http://localhost:3030/" />
</port>
- service.
Определяет адреса порта привязки. Сервис представляет собой набор сетевых конечных точек или портов.
4) Package.json позволяет упростить установка зависимостей между пакетами данных вручную, так как это очень трудоемкое и некомфортное занятие. Здесь у нас указано название проекта, его версия, имя автор и указан файл с сервером index.js.
5) Файл package-lock.json создается автоматически при установке Node.js пакетов. Его цель состоит в отслеживании точных версий установленных пакетов, что позволяет гарантированно сделать продукт рабочим и корректным.